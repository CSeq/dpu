\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[noadjust,nosort]{cite}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{MnSymbol}
%\usepackage{thmtools}
%\usepackage{thm-restate}
\usepackage{booktabs}
\usepackage{figlatex}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{xspace}
\usepackage[super]{nth}
\usepackage{multicol}
\usepackage{microtype}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage[center,width=152mm,height=235mm]{crop}
%\usepackage[pagewise,switch]{lineno} % switch, modulo, pagewise
\usepackage{hyperref}
%\usepackage[linesnumbered,lined,noend,ruled]{algorithm2e}
\usepackage[lined,noend,ruled]{algorithm2e}
\usepackage[capitalise,english,nameinlink]{cleveref} % load after algorithm2e and hyperref

\hypersetup{
  bookmarksdepth=2,
  bookmarksnumbered=true,
  bookmarksopen=true,
  bookmarksopenlevel=2,
  colorlinks=true,
  linktocpage=true,
  breaklinks=true,
  pageanchor=true,
  allcolors=[rgb]{0.6,0.0,0.0},
  pdftitle={DPU's data structures and algorithms},
  pdfauthor={Huyen N.T.T, César Rodríguez}
}

\input{defs}

\title{DPU Implementation Description}
\author{Huyen Nguyen}
\institute{Université Paris 13, Sorbonne Paris Cité, LIPN, CNRS, France}

\begin{document}

\maketitle
\noindent
\section{Conflicting extensions}
\subsection{WR conflicting events}
Compute all events that conflict with $e$ labelled by transition $t$
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item
	Use a function called $compute\_maxevt()$ to locate $max_varevt$, the set of maximal events touching variable $t \rightarrow
	 var$ in
	history of $[ep]$. 
\item Set \verb!ew = e!
\item If $\verb!ew! < \verb!ep!$, then goto End.
\item Let $c \eqdef \tup{s_1, \ldots, s_n}$ be the comb associated to \verb!ew!
	\begin{itemize}
	\item
		Set up the comb with spikes where $spikes[i]$ is a set of RD and WR events that are found by recursively exploring the
		pointer \verb!pre_readers[i]! until the first event of type \verb!WR! or bottom found.
	\item
		Remove from spikes those that precede any event in M, to assure the condition: None of events in $\set{e_1, \ldots, e_n}	
		$ is a causal predecessor of some event in $M$
\end{itemize}
\item
  Enumerate all combinations $\tup{e_1, \ldots, e_n}$ of $c$.
  For any of them, do:
  \begin{enumerate}
  \item
    If $\tup{e_1, \ldots, e_n} = \verb!e->pre_readers!$, then discard and take
    next one.
  \item
    Create (or retrieve) an event \verb!ex! such that
    \begin{itemize}
    \item \verb!ex->trans = t!,
    \item \verb!ex->pre_proc = ep!,
    \item \verb!ex->pre_readers = {e_1, ..., e_n}!,
    \end{itemize}
  \item
    Set \verb!ew! = spikes[0].back() 
  \end{enumerate}
\item Goto 3.
\item End.
\end{enumerate}


\begin{algorithm}
The purpose of the function is to find out all maximal events in calling event's history which read or write variable $var$. The resulting events are stored in a vector (std::vector) refered by $max\_varevt$.  
\begin{enumerate}
\item
	For each process $i$, starting from \verb!ee.proc_maxevt[i]!, go back by pointer \verb!pre_proc! until we reach the first event $pm$ that read or write variable $t \rightarrow var$ or bottom and then push it to $max_varevt$.
\item
	
\end{enumerate}

\label{a:pre_max}
\caption{Compute maximal event touching variable $var$ }
\end{algorithm}

\subsection{SYN conflicting events}
SYN events have some features that need to be noticed:
\begin{itemize}
\item
	An UNLOCk event can only be enabled at a LOCK in the same process, so it can not have conflicting events
\item
	
	
\end{itemize}

\end{document}