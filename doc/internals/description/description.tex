\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[noadjust,nosort]{cite}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{MnSymbol}
%\usepackage{thmtools}
%\usepackage{thm-restate}
\usepackage{booktabs}
\usepackage{figlatex}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{xspace}
\usepackage[super]{nth}
\usepackage{multicol}
\usepackage{microtype}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage[center,width=152mm,height=235mm]{crop}
%\usepackage[pagewise,switch]{lineno} % switch, modulo, pagewise
\usepackage{hyperref}
%\usepackage[linesnumbered,lined,noend,ruled]{algorithm2e}
\usepackage[lined,noend,ruled]{algorithm2e}
\usepackage[capitalise,english,nameinlink]{cleveref} % load after algorithm2e and hyperref

\hypersetup{
	bookmarksdepth=2,
	bookmarksnumbered=true,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	colorlinks=true,
	linktocpage=true,
	breaklinks=true,
	pageanchor=true,
	allcolors=[rgb]{0.6,0.0,0.0},
	pdftitle={DPU's data structures and algorithms},
	pdfauthor={Huyen N.T.T, César Rodríguez}
}

\input{defs}


\title{DPU Implementation Specification}
\author{Huyen Nguyen}
\institute{Université Paris 13, Sorbonne Paris Cité, LIPN, CNRS, France}

\begin{document}
\maketitle
\noindent
%\chapter{Execution Model}
Constructing the unfolding for a sytem is actually an exploration of all possible configurations from an input model.
\begin{itemize}
	\item
	 Input: A model M is described in terms of:
	 \begin{itemize}
	 	\item
		 	\verb!S!: A set of states where each one implies the states of all processes and variables of the system. Every system always has an well-defined initial state.
	 	\item
			\verb!T!: A set of transitions, one of who implies the system movement from one state to another.
	 	\item 
		 	\verb!P!: A set of processes with locations, transitions between them.
		
	 \end{itemize} 
	\item Output: A full unfolding with events labelled with transitions and relations including causality, conflict and concurrency.
\end{itemize}

\section{Execution Model}
\label{s:model}
\subsection{Data Structure}
\verb!Machine!: A class models a system in terms of:
	\begin{itemize}
	\item
		\verb!procs!: a vector (std::vector) of threads which are instances of \verb!Process! class
	\item
		\verb!trans!: a vector of transitions in all processes, instances of \verb!Transition! class 
	\item
		\verb!memsize!:	an \verb!int! number which is the size of memory dedicated to store the states of processes and
		 value of variables
	\item
		\verb!init_state!: a private initial state of system, an instance of \verb!State! class. This can be set up 
		by \verb!change_init_state! method
	\end{itemize}	


\subsection{Relevant classes}
Classes neccessary to model a system are State, Trans, Process:
\begin{enumerate}
\item
	\verb!State!: implies the state associated with a Machine $m$. The unique attribute \verb!tab! is an array of \verb!uint32_t! storing the process locations and variable values (including global and local variables) at the state. Its size is \verb!m.memsize!
\item
	\verb!Process!: A process is specified as:
	\begin{itemize}
	\item
		A vector of Trans instances
	\item
		A vector (std::vector) of vectors of \verb!Trans! indicates the control flow graph of the process
	\end{itemize}	 
\item
	\verb!Trans!: includes a numerous properties:
	\begin{itemize}
	\item
		\verb!proc!: the process which it belongs to.
	\item
		\verb!src!: the source location of the process
	\item
		\verb!dest!: a new location that the process can reach when the transitions is fired.
	\item
		\verb!var!: an $int$ number implying pthe address  of the only global variable which is touched
		 by transition in machine memory (\verb!tab! of \verb!State!)
	\item
		\verb!offset!: the offset address from the variable which is helpful just in case \verb!var! is an array.
	\item
		\verb!localvars!: a vector of local variables which are read or written by transition
	\item
		\verb!code!: an instance of Codeblock class, a source code associated with a transition which can be any statement in C
		 programming language.
	\item
		\verb!type!: type of transition which can be read, write, synchronous or local. 
		Transition types :
		\begin{itemize}
		\item
			\verb!RD! Represents a transition that performs a certain amount of local (independent) work plus a single read
			 operation on some global variable.
		\item
			\verb!WR! Represents a transition that performs a certain amount of local (independent) work plus a single write
			 operation on some global variable.
		\item
			\verb!LOC! Represents a transition that only performs local (independent) operations.
		\item
			\verb!SYN! Represents a synchronization operation, intended to model a lock or unlock operation on a mutex.
		\end{itemize}
		
	\end{itemize}
	
\noindent	
Importan methods:
	\begin{itemize}
	\item
		\verb!enable(State s)!: a function returns $true$ if the transition is enabled at the state $s$ 
	\item
		\verb!fire(State s)!: fire the transition from $s$ providing that $s$ is asserted to enable the calling transition.
	\end{itemize}
\end{enumerate}

\section{Unfolding}
\label{s:unf}
\subsection{Data Structure}
	A vector of \verb!Event!s, a pointer to the bottom event, and a reference to the \verb!Machine!.

\subsection{Relevant classes}
To represent and construct an unfolding, we need some classes including Config, Event, Node, Multinode:
\begin{enumerate}
\item
	\verb!Config!: a configuration represents a set of conflict-free and causal closed events in a unfolding.
	\begin{itemize}
	\item
		\verb!gstate!: the state which is reached by firing sequentially events in the configuration.
	\item
		\verb!latest_proc!: a vector of pointers refering to the latest event in processes, so its size is the number of
		 processes.
	\item
		\verb!latest_wr!: a vector of pointers refering to the latest event writing on a variable. Its size is equal to the
		 number of variables.
	\item
		\verb!latest_op!: a vector of vectors of pointers indicateing the latest event in each process which reads or writes on
		a variable. its size is the number of processes multiplied by the \verb!memsize! of input machine $m$.
	\item
		\verb!en!: a vector of pointers to those who are enabled at the state of the configuration.
	\item
		\verb!cex!: a vector of pointer to those who are enabled at some sub-configuration of C and conflict with some event in
		 C
	\end{itemize}
\item
	\verb!Event!: the most important class in the unfolding which contains almost all neccessary information. Events represent the occurrence of transitions.
They store pointers to all their immediate causal predecessors (ICPs), and some of
the immediate causal successors (ICSs).
The number of ICPs is determined by the type of the transition they
represent:

\begin{itemize}
\item \verb!LOC! events: 1 predecessor (process)
\item \verb!SYN! events: 2 predecessors (process, last \verb!SYN! on same variable)
\item \verb!RD!  events: 2 predecessor (process + last \verb!RD! or
	\verb!WR! operation on the same variable)
\item \verb!WR!  events: 1 predecessor (process) + one predecessor per
	process (last \verb!RD! or \verb!WR! operation on that process)
\end{itemize}

The immediate causal successors of one event are determined by those events
for which the event is an immediate causal predecessor. Some of the causal
successors are stored in the \verb!Event! class, but not all.

All kinds of events store:
\begin{itemize}
\item
  \verb!trans!: a pointer to the transition it represents.
\item
  \verb!localvars!: vector (\verb!std::vector!) of \verb!uint32_t! values
  containing the value of the variables whose addresses are strored in
  \verb!this->trans->localvars!.
\item
  \verb!pre_proc!: (ICP) a pointer to the last event in the same thread.
\item
  \verb!post_proc!: (ICSs) a vector (\verb!std::vector!) of pointers to
  the next events in the same thread.
\end{itemize}
%
For \verb!SYN! events :
\begin{itemize}
\item
  \verb!pre_mem!: (ICP) pointer to the last \verb!SYN! event on the same
  variable, possibly performed by the same thread or another thread.
  Recall that \verb!SYN! operations on the same variable induce a tree when
  regarded unfolding-wise, and a total order (a branch of that tree) when
  the attention is reduced to an arbitrary configuration.
  In this regard, \verb!pre_mem! is a pointer to the node's parent in that
  tree.
\item
  \verb!post_mem!: (ICSs) vector (\verb!std::vector!) of pointers to
  the immediate next \verb!SYN! operations on the same variable, in this or
  another thread. These are the children of the aforementionned
  unfolding-wise tree.
\item
  \verb!val!: the value written by this event to the variable \verb!trans->var!
\end{itemize}
%
For \verb!RD! events :
\begin{itemize}
\item
  \verb!pre_mem!: (ICP) pointer to the last \verb!RD! or \verb!WR! event of
  the same thread. Observe that we do not store anything in the
  \verb!post_mem! vector.
\end{itemize}
%
Finally, for \verb!WR! events :
\begin{itemize}
\item
  \verb!pre_mem!: (causal predecessor) pointer to the last event
  representing a \verb!WR! operation performed on the same variable.
  Recall that \verb!WR! operations on the same variable induce a tree when
  regarded unfolding-wise, and a total order (a branch of that tree) when
  the attention is reduced to an arbitrary configuration.
  In this regard, \verb!pre_mem! is a pointer to the node's parent in that
  tree.
\item
	
  \verb!post_wr!: (causal WR successsor) vector (\verb!std::vector!) of
  pointers to the next \verb!WR! operations on the same variable, in this
  or another thread. These are the children of the aforementionned
  unfolding-wise tree.(need re-considered its existence)
\item
  \verb!post_mem!: (causal RD, SYN, WR immediate successors) a vector of vectors (\verb!std::vector<std::vecotr>!) of operations on the same variable in differents threads. 
	
\item
  \verb!pre_readers!: (immediate and not immediate causal predecessors)
  vector (\verb!std::vector!) of pointers to events (one per thread).
  The event pointed is the last \verb!RD! or \verb!WR! operation on the
  same variable performed in that thread.
\end{itemize}

\item
	\verb!MultiNode!
\item
	\verb!Node!

\end{enumerate}

\section{Unfolding construction}
The algorithm to build the unfolding is to firsly explore a configuration from the bottom (initial state of system) by adding to it enable events one by one until reaching maximal events (there is no event enable at the state). At the place, we try to find an alternative to some event in the configuration. There may be several alternatives to a set of events but we choose the very first one found to be explored, the rest can be discovered in the coming times.
The exploration can be described in the following: 
\begin{enumerate}
\item 
	From the bottom ($C = \{\bot\}$), extend C by adding one of enabled event at the state of C until we reach a maximal
	event.
\item
	Compute conflict extension of C which will be detailed in the following parts of this document.
\item
	Find an alternative to D after C by judging all combinations of events which are in direct conflict with
	events in D individually. A combination is considered satisfied if it is conflict-free and causal-closed which means it
	forms a configuration.
\item
	If a configuration J is found, extend C by J and repeat the exploration in Step 1 for new configuration.
\item
	If no alternative is figured out, move one of maximal events in C to D, then repeat step 2.
\item
	The exploration termines when no event is enabled
\end{enumerate}

\subsection{Conflict extensions}
\label{s:cex}
Function \verb!compute_cex! computes conflict extension to a configuration C by generating all possible conflicting events for each one in C. Based on the type of transition an event is labelled with, either RD, WR or SYN, we have separate algorithms. 
\subsubsection{WR conflicting events}
\noindent
To compute all events that conflict with a WR event $e$ labelled with transition $t$, do as the following:

\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item
	Use function \verb!compute_maxevt()!(\cref{a:pre_max}) to locate \verb!max_varevt!, the set of maximal events touching variable $t \rightarrow var$ in history of $[ep]$. 
\item Set \verb!ew = e!
\item If $\verb!ew! < \verb!ep!$, then goto End.
\item Let $c \eqdef \tup{s_1, \ldots, s_n}$ be the comb associated to \verb!ew!
	\begin{itemize}
	\item
		Set up the comb with spikes where $spikes[i]$ is a set of RD and WR events that are found by recursively exploring the
		pointer \verb!pre_readers[i]! until the first event of type \verb!WR! or bottom found.
	\item
		Remove from spikes those that precede any event in \verb!max_varevt! which has been computed previously, to assure the condition: None of events in $\set{e_1, \ldots, e_n} $ is a causal predecessor of some event in $[ep]$
\end{itemize}
\item
  Enumerate all combinations $\tup{e_1, \ldots, e_n}$ of $c$.
  For any of them, do:
  \begin{enumerate}
  \item
    If $\tup{e_1, \ldots, e_n} = \verb!e->pre_readers!$, then discard and take
    next one.
  \item
    Create (or retrieve) an event \verb!ex! such that
    \begin{itemize}
    \item \verb!ex->trans = t!,
    \item \verb!ex->pre_proc = ep!,
    \item \verb!ex->pre_readers = {e_1, ..., e_n}!,
    \end{itemize}
  \item
    Set \verb!ew! = spikes[0].back() 
  \end{enumerate}
\item Goto 3.
\item End.
\end{enumerate}

\begin{algorithm}
\label{a:pre_max}
The purpose of the function is to find out all maximal events in calling event's history which read or write variable $var$. The resulting events are stored in a vector (std::vector) refered by $max\_varevt$.  
\begin{enumerate}
\item
	For each process $i$, starting from \verb!ee.proc_maxevt[i]!, go back by pointer \verb!pre_proc! until we reach the first
	event $pm$ that read or write variable $t \rightarrow var$ or bottom	
\item
	Push it to \verb!max_varevt!.
\end{enumerate}
\caption{Fucntion compute maxevt}
\end{algorithm}

\subsubsection{RD conflicting events}
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!em = e->pre_mem!
\item If $\verb!em! < \verb!ep!$, then goto End.
\item If \verb!em! is \verb!RD!, then set \verb!em = em->pre_mem!
\item If not, it must necessarily be \verb!WR!; then set \verb!em = em->pre_readers[t->proc]!
\item (Warning: check for the bottom event in previous calculation)
\item
  Create (or retrieve) an event \verb!ex! such that
  \begin{itemize}
  \item \verb!ex->trans = t!,
  \item \verb!ex->pre_proc = ep!,
  \item \verb!ex->pre_mem = em!,
  \end{itemize}
  
\item Check if \verb!ex! is enabled at the new local configuration
\item Event \verb!ex! is in $\cex C$
\item Goto 4.
\item End.
\end{enumerate}

\subsubsection{SYN conflicting events}
\noindent
It is noticable for SYN events that an UNLOCK event can only be enabled from a LOCK and a LOCK is enabled from an UNLOCK.
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!em = e->pre_mem!
\item If $\verb!em! < \verb!ep!$, then goto End.
\item Set \verb!em = em->pre_mem!
\item (Warning: check for the bottom event in previous calculation)
\item
  If \verb!t! is enabled at the state of $[ep] \cup [em]$, then create (or retrieve) an event \verb!ex! such that
  \begin{itemize}
  \item \verb!ex->trans = t!,
  \item \verb!ex->pre_proc = ep!,
  \item \verb!ex->pre_mem = em!,
  \end{itemize}
\item Event \verb!ex! is in $\cex C$
\item Goto 3.
\item End.
\end{enumerate}

\subsection{Alternative}
\noindent
To find out an alternative to D after C, do as follows:
\begin{enumerate}
\item
	Remove from D all events in cex(C) which are computed in previous section \cref{s:cex}
\item
	Let $comb \eqdef \tup{s_1, \ldots, s_n}$ be the comb over D where 
	$s_i$ are the events in direct conflict to $e_i$: $s_i$ = $e_i \rightarrow$ \verb!dicfl!
\item
	Remove from the $comb$ all events that are in conflict with any maximal event of C. If the removal leaves some empty spike, 
	there is not any alternative no longer.
\item
	Enumerate all combinations $\tup{e_1, \ldots, e_n}$ of $c$.
\item
	For any of them, do:
	\begin{itemize}
		\item 
    		If $\tup{e_1, \ldots, e_n}$ is conflict-free (use function \verb!check_cfl!), return $J = \cup [e_i]$. Remove from J those that are already in C.
   		\item
			If there exist any conflict among events in J, then discard J and come back to step 2
			to take next combination.
	\end{itemize}
\item End.
\end{enumerate}
%\caption{Computing an alternative J for D after C}
%\label{a:alter}

\end{document}