\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[noadjust,nosort]{cite}
\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{MnSymbol}
%\usepackage{thmtools}
%\usepackage{thm-restate}
\usepackage{booktabs}
\usepackage{figlatex}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{xspace}
\usepackage[super]{nth}
\usepackage{multicol}
\usepackage{microtype}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage[center,width=152mm,height=235mm]{crop}
%\usepackage[pagewise,switch]{lineno} % switch, modulo, pagewise
\usepackage{hyperref}
%\usepackage[linesnumbered,lined,noend,ruled]{algorithm2e}
\usepackage[lined,noend,ruled]{algorithm2e}
\usepackage[capitalise,english,nameinlink]{cleveref} % load after algorithm2e and hyperref

\hypersetup{
	bookmarksdepth=2,
	bookmarksnumbered=true,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	colorlinks=true,
	linktocpage=true,
	breaklinks=true,
	pageanchor=true,
	allcolors=[rgb]{0.6,0.0,0.0},
	pdftitle={DPU's data structures and algorithms},
	pdfauthor={Huyen N.T.T, César Rodríguez}
}

\input{defs}


\title{DPU Implementation Specification}
\author{Huyen Nguyen}
\institute{Université Paris 13, Sorbonne Paris Cité, LIPN, CNRS, France}

\begin{document}
\maketitle
\noindent
%\chapter{Execution Model}
Constructing the unfolding for a sytem is actually an exploration of all possible configurations from an input model.
\begin{itemize}
	\item
	 Input: A model M is described in terms of:
	 \begin{itemize}
	 	\item
		 	\verb!S!: A set of states where each one implies the states of all processes and variables of the system. Every system always has an well-defined initial state.
	 	\item
			\verb!T!: A set of transitions, one of who implies the system movement from one state to another.
	 	\item 
		 	\verb!P!: A set of processes with locations, transitions between them.
		
	 \end{itemize} 
	\item Output: A full unfolding with events labelled with transitions and relations including causality, conflict and concurrency.
\end{itemize}

\section{Execution Model}
\label{s:model}
\subsection{Data Structure}
\verb!Machine!: A class models a system in terms of:
	\begin{itemize}
	\item
		\verb!procs!: a vector (std::vector) of threads which are instances of \verb!Process! class
	\item
		\verb!trans!: a vector of transitions in all processes, instances of \verb!Transition! class 
	\item
		\verb!memsize!:	an \verb!int! number which is the size of memory dedicated to store the states of processes and
		 value of variables
	\item
		\verb!init_state!: a private initial state of system, an instance of \verb!State! class. This can be set up 
		by \verb!change_init_state! method
	\end{itemize}	


\subsection{Relevant classes}
Classes neccessary to model a system are State, Trans, Process:
\begin{enumerate}
\item
	\verb!State!: implies the state associated with a Machine $m$. The unique attribute \verb!tab! is an array of \verb!uint32_t! storing the process locations and variable values (including global and local variables) at the state. Its size is \verb!m.memsize!
\item
	\verb!Process!: A process is specified as:
	\begin{itemize}
	\item
		A vector of Trans instances
	\item
		A vector (std::vector) of vectors of \verb!Trans! indicates the control flow graph of the process
	\end{itemize}	 
\item
	\verb!Trans!: includes a numerous properties:
	\begin{itemize}
	\item
		\verb!proc!: the process which it belongs to.
	\item
		\verb!src!: the source location of the process
	\item
		\verb!dest!: a new location that the process can reach when the transitions is fired.
	\item
		\verb!var!: an $int$ number implying pthe address  of the only global variable which is touched
		 by transition in machine memory (\verb!tab! of \verb!State!)
	\item
		\verb!offset!: the offset address from the variable which is helpful just in case \verb!var! is an array.
	\item
		\verb!localvars!: a vector of local variables which are read or written by transition
	\item
		\verb!code!: an instance of Codeblock class, a source code associated with a transition which can be any statement in C
		 programming language.
	\item
		\verb!type!: type of transition which can be read, write, synchronous or local. 
		Transition types :
		\begin{itemize}
		\item
			\verb!RD! Represents a transition that performs a certain amount of local (independent) work plus a single read
			 operation on some global variable.
		\item
			\verb!WR! Represents a transition that performs a certain amount of local (independent) work plus a single write
			 operation on some global variable.
		\item
			\verb!LOC! Represents a transition that only performs local (independent) operations.
		\item
			\verb!SYN! Represents a synchronization operation, intended to model a lock or unlock operation on a mutex.
		\end{itemize}
		
	\end{itemize}
	
\noindent	
Importan methods:
	\begin{itemize}
	\item
		\verb!enable(State s)!: a function returns $true$ if the transition is enabled at the state $s$ 
	\item
		\verb!fire(State s)!: fire the transition from $s$ providing that $s$ is asserted to enable the calling transition.
	\end{itemize}
\end{enumerate}

\section{Unfolding}
\label{s:unf}
\subsection{Data Structure}
	A vector of \verb!Event!s, a pointer to the bottom event, and a reference to the \verb!Machine!.

\subsection{Relevant classes}
To represent and construct an unfolding, we need some classes including Config, Event, Node, Multinode:
\begin{enumerate}
\item
	\verb!Config!: a configuration represents a set of conflict-free and causal closed events in a unfolding.
	\begin{itemize}
	\item
		\verb!gstate!: the state which is reached by firing sequentially events in the configuration.
	\item
		\verb!latest_proc!: a vector of pointers refering to the latest event in processes, so its size is the number of
		 processes.
	\item
		\verb!latest_wr!: a vector of pointers refering to the latest event writing on a variable. Its size is equal to the
		 number of variables.
	\item
		\verb!latest_op!: a vector of vectors of pointers indicateing the latest event in each process which reads or writes on
		a variable. its size is the number of processes multiplied by the \verb!memsize! of input machine $m$.
	\item
		\verb!en!: a vector of pointers to those who are enabled at the state of the configuration.
	\item
		\verb!cex!: a vector of pointer to those who are enabled at some sub-configuration of C and conflict with some event in
		 C
	\end{itemize}
\item
	\verb!Event!: the most important class in the unfolding which contains almost all neccessary information. Events represent the occurrence of transitions.
They store pointers to all their immediate causal predecessors (ICPs), and some of
the immediate causal successors (ICSs).
The number of ICPs is determined by the type of the transition they
represent:

\begin{itemize}
\item \verb!LOC! events: 1 predecessor (process)
\item \verb!SYN! events: 2 predecessors (process, last \verb!SYN! on same variable)
\item \verb!RD!  events: 2 predecessor (process + last \verb!RD! or
	\verb!WR! operation on the same variable)
\item \verb!WR!  events: 1 predecessor (process) + one predecessor per
	process (last \verb!RD! or \verb!WR! operation on that process)
\end{itemize}

The immediate causal successors of one event are determined by those events
for which the event is an immediate causal predecessor. Some of the causal
successors are stored in the \verb!Event! class, but not all.

All kinds of events store:
\begin{itemize}
\item
  \verb!trans!: a pointer to the transition it represents.
\item
  \verb!localvars!: vector (\verb!std::vector!) of \verb!uint32_t! values
  containing the value of the variables whose addresses are strored in
  \verb!this->trans->localvars!.
\item
  \verb!pre_proc!: (ICP) a pointer to the last event in the same thread.
\item
  \verb!post_proc!: (ICSs) a vector (\verb!std::vector!) of pointers to
  the next events in the same thread.
\end{itemize}
%
For \verb!SYN! events :
\begin{itemize}
\item
  \verb!pre_mem!: (ICP) pointer to the last \verb!SYN! event on the same
  variable, possibly performed by the same thread or another thread.
  Recall that \verb!SYN! operations on the same variable induce a tree when
  regarded unfolding-wise, and a total order (a branch of that tree) when
  the attention is reduced to an arbitrary configuration.
  In this regard, \verb!pre_mem! is a pointer to the node's parent in that
  tree.
\item
  \verb!post_mem!: (ICSs) vector (\verb!std::vector!) of pointers to
  the immediate next \verb!SYN! operations on the same variable, in this or
  another thread. These are the children of the aforementionned
  unfolding-wise tree.
\item
  \verb!val!: the value written by this event to the variable \verb!trans->var!
\end{itemize}
%
For \verb!RD! events :
\begin{itemize}
\item
  \verb!pre_mem!: (ICP) pointer to the last \verb!RD! or \verb!WR! event of
  the same thread. Observe that we do not store anything in the
  \verb!post_mem! vector.
\end{itemize}
%
Finally, for \verb!WR! events :
\begin{itemize}
\item
  \verb!pre_mem!: (causal predecessor) pointer to the last event
  representing a \verb!WR! operation performed on the same variable.
  Recall that \verb!WR! operations on the same variable induce a tree when
  regarded unfolding-wise, and a total order (a branch of that tree) when
  the attention is reduced to an arbitrary configuration.
  In this regard, \verb!pre_mem! is a pointer to the node's parent in that
  tree.
\item
	
  \verb!post_wr!: (causal WR successsor) vector (\verb!std::vector!) of
  pointers to the next \verb!WR! operations on the same variable, in this
  or another thread. These are the children of the aforementionned
  unfolding-wise tree.(need re-considered its existence)
\item
  \verb!post_mem!: (causal RD, SYN, WR immediate successors) a vector of vectors (\verb!std::vector<std::vecotr>!) of operations on the same variable in differents threads. 
	
\item
  \verb!pre_readers!: (immediate and not immediate causal predecessors)
  vector (\verb!std::vector!) of pointers to events (one per thread).
  The event pointed is the last \verb!RD! or \verb!WR! operation on the
  same variable performed in that thread.
\end{itemize}

\item
	\verb!MultiNode!
\item
	\verb!Node!

\end{enumerate}

\section{Event and Conflict}
\subsection{Immediate conflict}
Two events $e$ and $e'$ are in \textit{immediate conflict} $e \icfl e' $ iff $e \cfl e'$ and both $[e] \cup \lceil e' \rceil$ and $ \lceil e \rceil \cup [e']$ are configuration. Saying non-mathematically, they take 

To determine immediate conflict between two events $e$ and $e'$: 
\begin{itemize}
	\item
	One of them is a LOC, there is no conflict at all.
	\item
	If they have the same predecessor \verb!e.pre_proc = e'.pre_proc!, the look at their local configuration.
	\item
	If they are in different processes (have different \verb!pre_proc!), look at one event's \verb!parent! \verb!e.pre_mem! (watch out the case where its parent is $bottom$ - a special WR)
	\begin{itemize}
		\item
		\verb!parent! is RD or SYN: if we find $e'$ in its \verb!post_rws!, then they are in
		conflict.
		\item
		\verb!parent! is WR: if we find $e$ and $e'$ in the same vector of \verb!e.post_mem!,
		they are in conflict (e can be a WR, so it can appear in all vectors of 
		\verb!e.post_mem!, not only the vector of its process)
	\end{itemize}
	
\end{itemize}

\subsubsection{Checking direct conflict}
Every event in the unfolding should have a list of events which are in conflict with it, called $dicfl$. This set is updated when events are created or something which can cause changes in relationships among events happens.
An event can be created in two cases:
\begin{enumerate}
	\item
	A transition is enabled at the state of configuration, one event labelling by that is
	created and added to enable set. At the time of creating an event, we need to update their $dicfl$. If there exist any $e'$ in en(C) which conflicts with $e$,
	move $e'$ to cex(C) and update their direct conflict sets $dicfl$ at the same time. 		
	
	\begin{lemma}{Direct conflict between enable events}
		\begin{itemize}
			\item
			$e$ and $e'$ are both in en(C), $e \icfl e'$ iff they share at least one parent.		
		\end{itemize}
		\label{thm:lem1}
	\end{lemma}
	
	\begin{proof}
		\begin{itemize}
		\item
			($\leftarrow$) $e$ and $e'$ have a common parent $\rightarrow$ $e \icfl e'$
			
			$e$ and $e'$ sharing one parent means that  $e \cfl e'$. Moreover, $e$ and $e'$ are both in
			en(C), so we have:
			\begin{itemize}
			\item
				$\lceil e \rceil \cup e'$ is a configuration.
			\item
				$\lceil e' \rceil \cup e$ is a configuration.
			\end{itemize} 
			According to the definition of direct conflict, it is obvious that $e \icfl e'$.
			
		\item
			($\rightarrow$) $e \icfl e'$ $\rightarrow$ they have at least one parent in common.
			
			Assume that $e$ and $e'$ share no parent, because $\lceil e \rceil \cup e'$ and $\lceil
			e' \rceil \cup e$ are configurations, $e || e'$ which means $\lnot (e \cfl e')$
		\end{itemize}			
	\end{proof}			
	
	\iffalse			
	Thank to \autoref{thm:lem1}, to decide if they are in conflict, just check their parents
	together. If there is at least one shared parent between them, they are in direct conflict.
	Otherwise, they are not. Use \verb!post_mem! field to check shared parents.
	
	Let us take the type of transition into account: 
	Note that they are in a enable set of configuration, so they cannot share\verb!	pre_proc!.
	\begin{itemize}
		\item
		If either $e$ or $e'$ is a LOC: two events definitly share no parent (thank to the
		deterministic feature of the model) which implies that they are not in conflict 
		(including direct conflict).
		\item
		If they are two RDs or two SYNs or a pair of (RD, SYN):
		\begin{itemize}
			\item
			If \verb!e.pre_mem = e'.pre_mem!, they are not in conflict but concurrent.
			\item
			If we have \verb!e.pre_proc = e'.pre_mem! or 
			\verb!e.pre_mem =  e'.pre_proc!, $e$ and $e'$ are in direct conflict.
		\end{itemize}
		
		\item
		If ($e$. $e'$) is a pair of (RD, WR) or (SYN, WR): 
		\begin{itemize}
			\item
			If \verb!e.pre_mem = e'.pre_proc!, we have $e \icfl e'$
			\item
			If \verb!e.pre_mem! or \verb!e.pre_proc! is the same as one of 
			\verb!e'.pre_readers!, it is definitely that $e \icfl e'$
		\end{itemize}
		
		\item
		If both are WRs, check \verb!e.pre_proc! and \verb!e.pre_readers! with
		\verb!e'.pre_proc! and all \verb!e'.pre_readers!. If there exist a pair with the
		same index, $e$ and $e'$ conflict directly.
	\end{itemize}
	\fi
	
	\begin{algorithm}{}
		Given two events $e$ and $e'$ in the enable set of configuration C, 
		do as follows to check the direct (immediate) conflict between them:
		\begin{enumerate}
			\item 
			Ignore \verb!pre_proc! because it does not affect the conflict at all.
			\item
			If \verb!e.trans->type! is RD or SYN, set \verb!parent = e.pre_mem!
			\item
			If \verb!e.trans->type == WR!,
			
			for each \verb!e.pre_readers[i]! $(i \in [0..numprocs])$,
			
			set \verb!parent = e.pre_readers[i]!
			
		\end{enumerate}
		Let's consider $parent$.
		
		\begin{itemize}
			\item
			\verb!parent->trans->type! is RD or SYN: 
			If found(e') in \verb!parent.post_rws!, then $e$ and $e'$ are in immediate
			conflict
			\item
			\verb!parent->trans->type! is WR: If found(e) and found(e') in the same 
			\verb!parent.post_mem[i]!, then they definitely
			conflict immediately.
		\end{itemize}
		\noindent
		\caption{Check direct conflict between two enabled events}
		\label{a:dicfl}
	\end{algorithm}
	
	\item
	A new event conflicting with an event $e$ labelled with transition $t$ is created by
	combining \verb!e.pre_proc! and new \verb!pre_mem! and \verb!pre_readers! (for a WR).
	Find $ex$ with the same transition, same \verb!pre_proc! but different \verb!pre_mem! or
	\verb!pre_readers!. See \cref{ss:cex_rd}, \cref{ss:cex_syn} and \cref{ss:cex_wr} for more
	details.
	
	\begin{lemma}{Direct conflict in conflict extension}
		\begin{itemize}
			\item
			If $ex$ is a SYN, RD, it will be in immidiate conflict with \verb!ex.post_rws! which can be discovered by backtracking from \verb!e.pre_mem!.
			\item
			If $ex$ is a WR, it will conflict directly with several events according to \verb|ex.pre_readers|. For each \verb|ex.pre_readers[i]| with i=\{0..numprocs\}, do as follows:
			\begin{itemize}
				\item 
					If \verb|e.pre_readers[i] = ex.pre_readers[i]|, then there is no directly conflicting event in branch $i$. Move to the next branch.
				\item
					If \verb|e.pre_readers[i] != ex.pre_readers[i]|, find such \verb|e'| that it is immediate successor of \verb|ex| and \verb|e'< e.pre_readers[i]|
			\end{itemize}
		\end{itemize}
	\end{lemma}
	
\end{enumerate}

\subsection{General Conflict}
\subsubsection{Definition}
\subsubsectionmark{3.2.1}
\subsubsection{Checking conflict between two events in the same tree}
Tree are divided into layers whose events have the same depth and are in immediate conflict.
e and e' are two events in that tree at depths $e.depth$ and $e'.depth$ respectively.
\begin{itemize}
	\item
	If $e.depth = e'.depth$, then $e \icfl e'$
	\item
	If $e.depth \neq e'.depth$, without loss of any generality, assume $ depth(e) > depth(e')$ . Find an event $e": e" < e$ and $e".depth = e'.depth$ . If $e" \equiv e'$, then $e'$ and $e$ are in causality, else they are in conflict.
\end{itemize}


To quickly find $e"$ through the tree, we use the idea of skip list
(see \ref{fig:example}).
Accordingly, in each node, a list of skip predecessors $
skip\_preds = (i_1, i_2,..,i_m)$ are stored, where $i_j$ $(j \in [1,m] )$ is the
node's predecessor in $k^{j}$ distance of depth, k (k > 1) is a constant
distance in depth choosen to skip.\\

\noindent
\textbf{Data structure:}
Using template struct \verb!Node<T>:!
\begin{itemize}
	\item \textit{depth}: the distance from the root
	\item \textit{*pre}: according to the type of tree, it points to node of T which is immediate predecessor (\verb!pre-proc! or \verb!pre_mem! in Event class)
	\item \textit{skip\_preds}: list of pointers to its k-skip predecessors of type T.	
	(T can be an event in the same process or touching the same variable)
\end{itemize}

To apply the algorithm of skip list to layered trees, we use a template class \verb!MultiNode<T>! (T is Event) which has the following attributes:
\begin{itemize}
	\item list of two \verb!Node! (first one for process, second one for variable)
	\item a template function $pred()$ to locate the predecessor corresponding to type of \verb!Node!
\end{itemize}

Class Event inherits \verb!MultiNode<T>! and has two template function indicating which type of Node to take into account.
\begin{itemize}
	\item	
	\verb!Node<Event> &proc!: return node in equivalant \textit{process} tree
	\item	
	\verb!Node<Event> &var!: return node in equivalant \textit{variable} tree 	
\end{itemize}

\noindent
\textbf{Initialize a list of skip predecessors} \verb!skip_preds:!
\begin{itemize}
	\item
	Firstly, we need to define the size $s$ of vector \verb!skip_preds! of a node. It depends on the depth of the node.
	
	$s = max(i \in [1,\infty]: e.depth \mod k^{i} = 0 )$ 
	\item
	Next, compute the entire list of skip predecessors for e. For every node, $e.skip\_preds[i]$ is a predecessor which is in a depth 			distance of $k^{i}$ with e, so that:
	\begin{itemize}
		\item
		The first element of the list \verb!skip_preds[0]! indicates the predecessor which is in a depth distance of $k^1 = k$. It can 				be reached by backtracking with $pre$ which is actually \verb!pre_proc! or \verb!pre_mem! of corresponding event.
		\item
		For $\forall i \in [1,s]: skip\_preds[i] = max(\{e": e" < e$ and $e".depth \mod k^i = 0\})$ which can be computed by going back 			k times with $skip\_preds[i-1]$: \\
		\verb!e.skip_preds[i] = e.skip_preds[i-1]....skip_preds[i-1]! (k times) 
	\end{itemize}
\end{itemize}

\begin{algorithm}
	\noindent
	Assume $e.depth > e'.depth$, and , to reach e', do as follows:
	\begin{enumerate}
		\item
		\verb!Set next = e!
		\item
		\verb!while! $next.depth \neq e'.depth$ \verb!do!
		\begin{itemize}
			\item
			\verb!Set d  = next.depth - e'.depth!
			\item
			\verb!Set i  = 0!
			\item
			\verb!while! ($ next.depth \mod k^{i} = 0$)   \space \verb!do!
			$i = i + 1$
			\item
			\verb!Set! $next = next.skip\_preds[i]$ 
		\end{itemize} 
		\item 
		If $next \equiv e'$ then 
		$e'< e$ 
		
		else $e'\cfl e$	 
	\end{enumerate}
	\caption{Decide the conflict between e and e' in the same tree}
	\label{a:layer_tree}	
\end{algorithm}

\begin{algorithm}
	Given two reads $e$ and $e'$.
	\begin{enumerate}
		\item
		Set \verb!w1 = e.find_WR_pred() !
		\verb!w2 = e'.find_WR_pred()!
		\item
		If $w_1 == w_2$
		return false;
		\item
		If $w_1 \cfl w_2$
		return true;
		\item
		If $w_2$ is a successor of $w_1$
		\begin{itemize}
			\item
			Set $w'$ is WR predecessor of $w_2$ at the $w_1.depth + 1$
			\item
			Set $r_1$ = \verb!w'.pre_preaders[e->trans->proc.id]!
			\item
			If ($e$ < $r_1$) then $\lnot (e \cfl e')$
			
			else 	$e \cfl e'$;
		\end{itemize}
		else
		\begin{itemize}
			\item
			Set $w'$ is WR predecessor of $w_1$ at the $w_2.depth + 1$
			\item
			Set $r_1$ = \verb!w'.pre_preaders[e'->trans->proc.id]!
			\item
			If ($e'$ < $r_1$) then $\lnot (e \cfl e')$
			
			else 	$e \cfl e'$;
		\end{itemize}
		
	\end{enumerate}
	\caption{Decide the conflict between two RDs}
	\label{a:rds}	
\end{algorithm}

\begin{algorithm}
	Given two events $e$ is a WR and $e'$ is a RD
	\begin{enumerate}
		\item
		Set 	\verb!w2 = e'.find_WR_pred()!
		\item
		If $e == w_2$
		return false;
		\item
		If $e \cfl w_2$
		return true;
		\item
		If $w_2$ is a successor of $e$
		then $e < e'$
		else
		\begin{itemize}
			\item
			Set $w'$ is WR predecessor at the $w_2.depth + 1$
			\item
			Set $r_1 = w'.pre\_preaders[e'->trans->proc.id]$
			\item
			If ($e'$ precedes $r_1$) then $\lnot (e \cfl e')$
			
			else 	$e \cfl e'$;
		\end{itemize}
		
	\end{enumerate}
	\caption{Decide the conflict between a WR and a RD}
	\label{a:wrd}	
\end{algorithm}

\begin{algorithm}
	Given two events touching different variables or 2 LOCs $e$ and $e'$.
	Do the following:
	\begin{enumerate}
		\item
		For each pair $(e_i, e_i')$ of maximal events of each process:
		$e_i \in$ \verb!e.proc_maxevt! and $e_i' \in$ \verb!e'.proc_maxevt! do: \\
		\begin{itemize}
			\item
			If $e_i$.\verb!check_conflict_same_tree(!$e_i'$ \verb!)! is $true$, then  return true;
			\item
			Else jump to 2
		\end{itemize}
		
		\item
		For each pair $(e_i, e_i')$ of maximal events of each process:
		$e_i \in $ \verb!e.var_maxevt! and $e_i' \in$ \verb!e'.var_maxevt! do:\\
		\begin{itemize}
			\item
			If $e_i$.\verb!check_conflict_same_tree(!$e_i'$ \verb!)! is $true$, then  return true;
			\item
			Else, return false;
		\end{itemize}
		
	\end{enumerate}
	\caption{Decide the conflict between 2 LOCs}
	\label{a:arb}	
\end{algorithm}


\section{Unfolding construction}
The algorithm to build the unfolding is to firstly explore a configuration from the bottom (initial state of system) by adding one by one enabled events until reaching maximal events (there is no event enable at the state). At that place, we try to find an alternative to some event in the configuration. There may be a number of such alternatives but we take the very first found one to explore, the rest can be discovered in the coming times.
The exploration can be described as the following: 
\begin{enumerate}
\item 
	From the bottom ($C = \{\bot\}$), extend C by adding one of enabled events at the state of C (initial state at the beginning) until we reach a maximal one.
\item
	Compute conflict extension for maximal configuration C (details in \cref{s:cex}).
\item
	Find an alternative to D after C by judging all combinations of events which are in direct conflict with
	events in D individually. A combination is considered satisfied if it is conflict-free and causal-closed which means it
	forms a configuration.
\item
	If a configuration J is found, extend C by J and repeat the exploration in Step 1 for new configuration.
\item
	If no alternative is figured out, move one of maximal events in C to D, then repeat step 2.
\item
	The exploration termines when no event is enabled
\end{enumerate}

\subsection{Conflict extensions}
\label{s:cex}
Function \verb!compute_cex! computes conflict extension to a configuration C by generating all possible conflicting events for each one in C. Based on the type of transition an event is labelled with, either RD, WR or SYN, we have separate algorithms. 
\subsubsection{WR conflicting events}
\label{ss:cex_wr}
\noindent
To compute all events that conflict with a WR event $e$ labelled with transition $t$, do as the following:

\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item
	Use function \verb!compute_maxevt()! \cref{a:max} to locate \verb!max_varevt!, the set of maximal events touching variable $t \rightarrow var$ in history of $[ep]$. 
\item Set \verb!ew = e!
\item If $\verb!ew! < \verb!ep!$, then goto End.
\item Let $c \eqdef \tup{s_1, \ldots, s_n}$ be the comb associated to \verb!ew!
	\begin{itemize}
	\item
		Set up the comb whose $spikes[i]$ is a set of RD and WR events that are found by recursively exploring the
		pointer \verb!pre_readers[i]! until the first event of type \verb!WR! or bottom is found.
	\item
		Remove from spikes those that precede any event in \verb!max_varevt! (computed previously), to assure the condition: None of events in $\set{e_1, \ldots, e_n} $ is a causal predecessor of some event in $[ep]$
	\item
		Remember to check empty spikes whenever doing removal on the comb.
\end{itemize}
\item
  Enumerate all combinations $\tup{e_1, \ldots, e_n}$ of $c$ by recursive algorithm.
  For any of them, do:
  \begin{enumerate}
  \item
    If $\tup{e_1, \ldots, e_n} = \verb!e->pre_readers!$, then discard and take
    next one.
  \item
    Create (or retrieve) an event \verb!ex! such that
    \begin{itemize}
    \item \verb!ex->trans = t!,
    \item \verb!ex->pre_proc = ep!,
    \item \verb!ex->pre_readers = {e_1, ..., e_n}!,
    \item \verb!ex->pre_mem = pm! (pm is the first WR found by recursively tracking with pointer \verb!pre_mem!)
    \end{itemize}
  \item
  	Check \verb!ex!'s existence in unfolding with function $find\_or\_add()$. If there does not exist an
  	event in the unfolding having the same \verb!Ident!, add \verb!ex! to the unfolding.
  \item
  	New event created in the unfolding will be added to \verb!cex!. If \verb!ex! is already in the
  	unfolding, it is definitely already in the \verb!cex!
  \item
  	Update \verb!dicfl! (set of directly conflicting events) for both \verb!ex! and other events which are in
  	immediate conflict with it. Refer \cref{a:dicfl} to see the algorithm.
  \item
    Set \verb!ew! = spikes[0].back() 
  \end{enumerate}
\item Goto 3.
\item End.
\end{enumerate}

\begin{algorithm}
	The purpose of the function is to find out all maximal events in calling event's history which read or
	write variable $var$. The resulting events are stored in a vector (std::vector) refered by $max\_varevt
	$.  
	\begin{enumerate}
	\item
		For each process $i$, starting from \verb!ee.proc_maxevt[i]!, backtrack by pointer \verb!pre_proc!
		until we reach bottom or the first event $pm$ that reads or writes variable $t \rightarrow var$.	
	\item
		Push it to \verb!max_varevt!.
	\end{enumerate}
\label{a:max}
\caption{Function compute maxevt}
\end{algorithm}

\begin{algorithm}
	Given new conficting event \verb!ex! previously computed in $WR\_cex$ algorithm, the problem is to figure out which of \verb!pre_proc!, \verb!pre_mem! and \verb!pre_readers! are in direct conflict with \verb!ex!. 
\begin{itemize}
\item
	\verb!pre_proc! has no conflict with \verb!ex!
\item
	\verb!pre_mem! is not considered  in issue of conflict.
\item
	For each \verb!ex.pre_readers[i]!, do as the following:
	\begin{itemize}
	\item
		If \verb!ex.pre_readers[i] == e.pre_readers[i]!, then there's no event in conflict with \verb!ex!
		in \verb!i! branch. 
	\item
		If \verb!ex.pre_readers[i] < e.pre_readers[i]!, find \verb!ex!'s immediate successor \verb!es! by recursively tracking from \verb!e.pre_readers[i]!. Add \verb!ex! to \verb!es.dicfl! and reverse.
	\end{itemize}	 
\end{itemize}	
\label{a: dicfl}
\caption{Add to set of immediate conflict events}
\end{algorithm}

\subsubsection{RD conflicting events}
\label{ss:cex_rd}
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!em = e->pre_mem!
\item If $\verb!em! < \verb!ep!$, then goto End.
\item If \verb!em! is \verb!RD!, then set \verb!em = em->pre_mem!
\item If not, it must necessarily be \verb!WR!; then set \verb!em = em->pre_readers[t->proc]!
\item (Warning: check for the bottom event in previous calculation)
\item
  Create (or retrieve) an event \verb!ex! such that
  \begin{itemize}
  \item \verb!ex->trans = t!,
  \item \verb!ex->pre_proc = ep!,
  \item \verb!ex->pre_mem = em!,
  \end{itemize}
  
\item Check if \verb!ex! is enabled at the new local configuration
\item Event \verb!ex! is in $\cex C$
\item Goto 4.
\item End.
\end{enumerate}

\subsubsection{SYN conflicting events}
\label{ss:cex_syn}
\noindent
It is noticable for SYN events that an UNLOCK event can only be enabled from a LOCK and reverse.
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!em = e->pre_mem!
\item If  \verb!em < ep!, then goto End.
\item Set \verb!em = em->pre_mem->pre_mem! (skip the \verb!pre_mem! which does not have the same type of SYN)
\item (Warning: check for the bottom event in previous calculation)
\item
  If \verb!t! is enabled at the state of $[ep] \cup [em]$, then create (or retrieve) an event \verb!ex! such that
  \begin{itemize}
  \item \verb!ex->trans = t!,
  \item \verb!ex->pre_proc = ep!,
  \item \verb!ex->pre_mem = em!,
  \end{itemize}
\item Event \verb!ex! is in $\cex C$
\item Goto 3.
\item End.
\end{enumerate}

\subsection{Alternative}
\noindent
Given a configuration $C \subseteq U$ and a set of events $D \subset U$, an alternative to D after C is an configuration $J \subset U $ such that:

\begin{flalign}
C \cup J \text{ is a configuration} \label{eq1}\\
\text{For all event } e \in D \text{, there is some } e'\in C \cup J \text{ such that } e' \in  \icfl \{e\}  	\label{eq2}
\end{flalign}



\noindent
We know that $\forall e \in D: $ $e \in cex(C)$ or $e \in en(C)$. Therefore, $\forall e \in D: e \in cex(C)$ (computed in \cref{s:cex}), there exists an event $e' \in C: e' \icfl e$ which implies that $e$ is definitely satisfied and then it should not be taken into account. In the other case, $e \notin cex(C)$, do as follows to find out a J if it exists:

\begin{itemize}
\item 
	$A = \{e_i \in D: e_i \in en(C)\}$ (A is a D prunned any event in $cex(C)$). 
	Set up a \emph{comb} (over A),
	an $n$-tuple $c \eqdef \tup{s_1, \ldots, s_n}$ of sequences $s_i \in A^*$
	($i \in  \set{0,\ldots ,n}$ with $n = \left\vert{A} \right\vert$).
	Each sequence $s_i$ is called a \emph{spike} 
	which contains all events that are in immediate conflict with $e_{i} \in A$ (see \cref{a:dicfl} for direct conflict checking algorithm).
	If there is an empty spike, $e_i$ has no conflicting event, then there exists no J.
\item
	Given a comb $c$ witout any empty spike, a \emph{combination} over $c$ is any $n$-tuple $a = \tup{e_1, \ldots, e_n} \in A^n$ such that $e_i \in A$ is one element of the sequence $s_i \in A^*$, for $i \in \set{1, \ldots, n}$. \\
	$a$ is an alternative we are looking for if it holds both \eqref{eq1} and \eqref{eq2} in the definition: 	
\begin{itemize}
	\item
		If $\exists e_i \in a$: $e_i \cup C$ is not a configuration, it means \eqref{eq1} condition is not satisfied, then discard the combination.
	\item
		If \eqref{eq1} holds, check whether $a$ is conflict-free which means there is not any pair of event $(e_i, e_j)$ in conflict (see ...for conflict checking algorithm):
		\begin{itemize}
			\item
				If there exist a pair $(e_i, e_j)$ such that $e_i \cfl e_j$, discard the combination.
			\item
				If not, (2) condition is definitely satisfied. By then, J is formed as the union of local configurations of all events in $a$:
				\begin{equation}
				\nonumber
					J = \cup [e_i] \text{ with } \forall  e_i \in a
				\end{equation}
				 
		\end{itemize}
\end{itemize}
\end{itemize}


\begin{algorithm}
To find out an alternative to D after C, do as follows:
\begin{enumerate}
	\item
	Remove from D all events in cex(C). 
	\item
	Let $comb \eqdef \tup{s_1, \ldots, s_n}$ be the comb over D where 
	$s_i$ is a set of events in direct conflict with $e_i$: $s_i$ = $e_i \rightarrow$ \verb!dicfl!
	\item
	Remove from the $comb$ all events that are in conflict with any maximal event of C. If the removal leaves some empty spike, 
	there obviously exists no alternative, so go to End
	\item
	Enumerate all combinations $\tup{e_1, \ldots, e_n}$ of $c$.
	\item
	For any of them, do:
	\begin{itemize}
		\item 
		If $\tup{e_1, \ldots, e_n}$ is conflict-free (use function \verb!check_cfl!), return $J = \cup [e_i]$. (Caution: Remember to remove from J those are already in C.
		\item
		If there exist any conflict among events in J, then discard J and come back to step 2
		to take next combination.
	\end{itemize}
	\item End.
\end{enumerate}
\caption{Computing an alternative J for D after C}
\label{a:alter}
\end{algorithm}


\end{document}