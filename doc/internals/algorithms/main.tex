\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[noadjust,nosort]{cite}
\usepackage{amsmath}
\usepackage{amsfonts}
%\usepackage{MnSymbol}
%\usepackage{thmtools}
%\usepackage{thm-restate}
\usepackage{booktabs}
\usepackage{figlatex}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{xspace}
\usepackage[super]{nth}
\usepackage{multicol}
\usepackage{microtype}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage[center,width=152mm,height=235mm]{crop}
%\usepackage[pagewise,switch]{lineno} % switch, modulo, pagewise
\usepackage{hyperref}
%\usepackage[linesnumbered,lined,noend,ruled]{algorithm2e}
\usepackage[lined,noend,ruled]{algorithm2e}
\usepackage[capitalise,english,nameinlink]{cleveref} % load after algorithm2e and hyperref

\hypersetup{
  bookmarksdepth=2,
  bookmarksnumbered=true,
  bookmarksopen=true,
  bookmarksopenlevel=2,
  colorlinks=true,
  linktocpage=true,
  breaklinks=true,
  pageanchor=true,
  allcolors=[rgb]{0.6,0.0,0.0},
  pdftitle={DPU's data structures and algorithms},
  pdfauthor={Huyen N.T.T, César Rodríguez}
}

\input{defs}

\title{DPU's Data Structures and Algorithms}
%\author{Huyen Nguyen \and C\'esar Rodr\'{\i}guez}
\author{TBD}
\institute{Université Paris 13, Sorbonne Paris Cité, LIPN, CNRS, France}

\begin{document}

\maketitle

\begin{abstract}
TBD
\end{abstract}

\section{Execution Model}
\label{s:model}

Relevant classes:
\verb!Machine!,
\verb!Process!,
\verb!Trans!,
\verb!State!

Transition types :
\begin{itemize}
\item
  \verb!RD! Represents a transition that performs a certain amount of
  local (independent) work plus a single read operation on some global variable.
\item
  \verb!WR! Represents a transition that performs a certain amount of
  local (independent) work plus a single write operation on some global variable.
\item
  \verb!LOC! Represents a transition that only performs local (independent)
  operations.
\item
  \verb!SYN! Represents a synchronization operation, intended to model a
  lock or unlock operation on a mutex.
\end{itemize}

\subsection{Data Structure}

FIXME

\section{Unfolding}

Relevant classes:
\verb!Unfolding!.

\subsection{Data Structure}

A vector of \verb!Event!s, a pointer to the bottom event, and a reference
to the \verb!Machine!.

\section{Event}
Relevant classes:
\verb!Event!.

Events represent the occurrence of transitions.
They store pointers to all their immediate causal predecessors (ICPs), and some of
the immediate causal successors (ICSs).
The number of ICPs is determined by the type of the transition they
represent:

\begin{itemize}
\item \verb!LOC! events: 1 predecessor (process)
\item \verb!SYN! events: 2 predecessors (process, last \verb!SYN! on same variable)
\item \verb!RD!  events: 2 predecessor (process + last \verb!RD! or
	\verb!WR! operation on the same variable)
\item \verb!WR!  events: 1 predecessor (process) + one predecessor per
	process (last \verb!RD! or \verb!WR! operation on that process)
\end{itemize}

The immediate causal successors of one event are determined by those events
for which the event is an immediate causal predecessor. Some of the causal
successors are stored in the \verb!Event! class, but not all.

FIXME -- some of these events are only causal predecessors or successors,
not necessarily immediate predecessors or successors.

\subsection{Data Structure}

The members of the class \verb!Event! that are relevant on each instance of
the class depend on the type of the transition represented by the event.

All kinds of events store:
\begin{itemize}
\item
  \verb!trans!: a pointer to the transition it represents.
\item
  \verb!localvars!: vector (\verb!std::vector!) of \verb!uint32_t! values
  containing the value of the variables whose addresses are strored in
  \verb!this->trans->localvars!.
\item
  \verb!pre_proc!: (ICP) a pointer to the last event in the same thread.
\item
  \verb!post_proc!: (ICSs) a vector (\verb!std::vector!) of pointers to
  the next events in the same thread.
\end{itemize}
%
For \verb!SYN! events :
\begin{itemize}
\item
  \verb!pre_mem!: (ICP) pointer to the last \verb!SYN! event on the same
  variable, possibly performed by the same thread or another thread.
  Recall that \verb!SYN! operations on the same variable induce a tree when
  regarded unfolding-wise, and a total order (a branch of that tree) when
  the attention is reduced to an arbitrary configuration.
  In this regard, \verb!pre_mem! is a pointer to the node's parent in that
  tree.
\item
  \verb!post_mem!: (ICSs) vector (\verb!std::vector!) of pointers to
  the immediate next \verb!SYN! operations on the same variable, in this or
  another thread. These are the children of the aforementionned
  unfolding-wise tree.
\item
  \verb!val!: the value written by this event to the variable \verb!trans->var!
\end{itemize}
%
For \verb!RD! events :
\begin{itemize}
\item
  \verb!pre_mem!: (ICP) pointer to the last \verb!RD! or \verb!WR! event of
  the same thread. Observe that we do not store anything in the
  \verb!post_mem! vector.
\end{itemize}
%
Finally, for \verb!WR! events :
\begin{itemize}
\item
  \verb!pre_mem!: (causal predecessor) pointer to the last event
  representing a \verb!WR! operation performed on the same variable.
  Recall that \verb!WR! operations on the same variable induce a tree when
  regarded unfolding-wise, and a total order (a branch of that tree) when
  the attention is reduced to an arbitrary configuration.
  In this regard, \verb!pre_mem! is a pointer to the node's parent in that
  tree.
\item
  \verb!post_mem!: (causal successsor) vector (\verb!std::vector!) of
  pointers to the next \verb!WR! operations on the same variable, in this
  or another thread. These are the children of the aforementionned
  unfolding-wise tree.
\item
  \verb!pre_readers!: (immediate and not immediate causal predecessors)
  vector (\verb!std::vector!) of pointers to events (one per thread).
  The event pointed is the last \verb!RD! or \verb!WR! operation on the
  same variable performed in that thread.
\end{itemize}

FIXME - incomplete; look at my notes and fix


\subsection{Events in Conflict with an Event}

TBD.

\section{Configuration}
Relevant classes:
\verb!Config!.

\subsection{Data Structure}

\begin{itemize}
\item
  \verb!state!: the state reached by the configuration (type \verb!ir::State!).
\item
  \verb!latest_proc!:
  a vector of pointers to events. The size of the vector is the number of
  processes. Conceptually this represents a function from the set of processes
  to the set of events, which gives, for every process, the (unique) causally
  maximal event of that process in the configuration.

\item
  \verb!latest_wr!
  a vector of pointers to events. Size: the number of variables of the system.
  Conceptually this represents a function from the set of variables
  to the set of events, which gives, for every variable, latest (causally
  maximal) event that wrote to the variable (that event must correspond to a
  \verb!SYN! or \verb!WR! transition).

\item
  \verb!latest_op!
  a vector of pointers to events. Size: the number of variables times number of
  processes.
  Conceptually this represents a function $f \colon P \times V \to C$,
  where $P$ is the set of processes, $V$ is the set of variables, and $C$ the
  set of events in the configuration.
  The event $f (p,v)$ is the latest (causally maximal) operation that process
  $p$ performed on variable $v$ (it will correspond to a \verb!SYN!, \verb!WR!,
  or \verb!RD! transition).
\end{itemize}

\subsection{Enabled Events}

\begin{itemize}
\item
  Enumerate all transitions enabled at the \verb!state!
\item
  Using the members variables it is easy to construct new events.
\end{itemize}

\subsection{Conflicting Extensions}


Let $M$ be the input program model.
Let $\unf M \eqdef \tup{E,<,\cfl,h}$ be the unfolding of $M$.
Let $t$ be a transition of $M$ and $C \subseteq E$ a configuration of $\unf M$.
See \cite{RSSK15long} for a formal definition.

In the sequel we give an algorithm to compute the \emph{conflicting extensions}
of~$C$, defined as
$
\cex C \eqdef
\set{e \in \ex C \colon \exists e' \in C,\, e \icfl{} e'},
$
where the \emph{extensions} of~$C$, written $\ex C$,
are all those events outside~$C$ whose causes are included in~$C$.
Formally,
$
\ex C \eqdef
\set{e \in E \colon e \notin C \land \causes e \subseteq C}
$, where
$\causes e \eqdef \set{e' \in E \colon e' < e}$.
Again, see \cite{RSSK15long} to gain intuition about the necessity and motivation
behind these definitions.

Assume we are given a configuration $C$.
We want to compute all events in $\cex C$.
Let \verb!t! be a transition of $M$.
For each type of transition we give a different algorithm that computes all
events $e \in E$ such that $h(e) = t$:
\begin{itemize}
\item Apply \cref{a:cex_rd} if $t$ is \verb!RD! transition.
\item Apply \cref{a:cex_syn} if $t$ is \verb!SYN! transition.
\item Apply \cref{a:cex_wr} if $t$ is \verb!WR! transition.
\item If $t$ is a \verb!LOC! transition, then there is no conflicting extension
$e \in \cex C$ such that $h(e) = t$.
\end{itemize}

\begin{theorem}[Conflicting extensions]
Let $M$ be the model of a program as described in \cref{s:model}.
Let $C$ be an arbitrary configuration of $\unf M$.
Then the algorithm above computes exactly the set of events $\cex C$.
\end{theorem}
\begin{proof}
TBD
\end{proof}

\Cref{a:cex_wr} is slightly more complex than the algorithms for read and
synchronization transitions, and requires the following additional definitions.

Let $A$ be a set.
A \emph{comb} over~$A$ of size $n \in \N$ is an $n$-tuple
$c \eqdef \tup{s_1, \ldots, s_n}$ of sequences $s_i \in A^*$
over~$A$.
Each sequence $s_i$ of the $n$-tuple is called a \emph{spike}.
Given a comb $c$ of size~$n$,
a \emph{combination} of $c$ is any $n$-tuple $\tup{a_1, \ldots, a_n} \in A^n$
such that $a_i \in A$ is one of the elements of the sequence $s_i \in A^*$, for
$i \in \set{1, \ldots, n}$.

Let $e \in E$ be a \verb!WR! event in $\unf M$.
Let $\set{e_1, \ldots, e_n}$ be the set of \verb!pre_readers! of~$e$.
We define the \emph{comb associated to $e$} as the only comb
$\tup{s_1, \ldots s_n}$ of size~$n$ over~$E$ defined as follows:
\begin{itemize}
\item
  Sequence $s_i \in E^*$ is formed by all \verb!RD! events and the only
  \verb!WR! event that can be found by recursively exploring the pointer
  \verb!pre_mem! starting from event~$e_i$. The last event to include in the
  sequence is the first event of type \verb!WR! found during the exploration of
  the list.
\end{itemize}


\begin{algorithm}
\noindent
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!em = e->pre_mem!
\item If $\verb!em! < \verb!ep!$, then goto End.
\item If \verb!em! is \verb!RD! then set \verb!em = em->pre_mem!
\item If not it must necessarily be \verb!WR!; then set \verb!em = em->pre_readers[t->proc]!
\item (Warning: check for the bottom event in previous calculation)
\item
  Create (or retrieve) an event \verb!ex! such that
  \begin{itemize}
  \item \verb!ex->trans = t!,
  \item \verb!ex->pre_proc = ep!,
  \item \verb!ex->pre_mem = em!,
  \end{itemize}
\item Event \verb!ex! is in $\cex C$
\item Goto 4.
\item End.
\end{enumerate}
\caption{Conflicting extesions associated to \texttt{RD} transitions.}
\label{a:cex_rd}
\end{algorithm}

\begin{algorithm}
\noindent
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!em = e->pre_mem!
\item If $\verb!em! < \verb!ep!$, then goto End.
\item Set \verb!em = em->pre_mem!
\item (Warning: check for the bottom event in previous calculation)
\item
  Create (or retrieve) an event \verb!ex! such that
  \begin{itemize}
  \item \verb!ex->trans = t!,
  \item \verb!ex->pre_proc = ep!,
  \item \verb!ex->pre_mem = em!,
  \end{itemize}
\item Event \verb!ex! is in $\cex C$
\item Goto 3.
\item End.
\end{enumerate}

\caption{Conflicting extesions associated to \texttt{SYN} transitions.}
\label{a:cex_syn}
\end{algorithm}

\begin{algorithm}
\noindent
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!ew = e!
\item
  Let $M$ be the set of maximal events in $[e_p]$ that read or write variable
  \verb!t->var! ($M$ will either be a singleton with only \verb!WR! event or
  will contain exactly one \verb!RD! or \verb!WR! event per process)
\item If $\verb!ew! < \verb!ep!$, then goto End.
\item Let $c \eqdef \tup{s_1, \ldots, s_n}$ be the comb associated to \verb!ew!
\item
  Enumerate all combinations $\tup{e_1, \ldots, e_n}$ of $c$.
  For any of them, do:
  \begin{enumerate}
  \item
    If $\tup{e_1, \ldots, e_n} = \verb!e->pre_readers!$, then discard and take
    next one.
  \item
    If any event in $\set{e_1, \ldots, e_n}$ a causal predecessor of some event in
    $M$, then discard and take the next combination.
  \item
    Create (or retrieve) an event \verb!ex! such that
    \begin{itemize}
    \item \verb!ex->trans = t!,
    \item \verb!ex->pre_proc = ep!,
    \item \verb!ex->pre_readers = {e_1, ..., e_n}!,
    \end{itemize}
  \item
    Set \verb!ew! to the last element (\verb!WR! event) of $s_1$
    (or $s_2$, or $s_3$, or \ldots)
  \end{enumerate}
\item Goto 3.
\item End.
\end{enumerate}
\caption{Conflicting extesions associated to \texttt{WR} transitions.}
\label{a:cex_wr}
\end{algorithm}

\subsection{Alternatives}
Given a configuration $C \subset U$ and a set of events $D \subset U$, an alternative to D after C is an configuration $J \subset U $ such that:
\begin{itemize}
\item $C \cup J$ is a configuration
\item for all event $e \in D$ , there is some $e'\in C \cup J$ such that $e' \in  \icfl{e}$
\end{itemize}

We have $\forall e \in D: $ $e \in cex(C)$ or $e \in en(C)$.

If  $e \in cex(C)$, there exists an event $e' \in C: e'\icfl\{e\}$. So, it shouldn't be taken into account.
 
If $e \in en(C)$. Do as the followings to find out all possible J.

\begin{itemize}
\item 
	$A = \{e_i \in D: e_i \in en(C)\}$. 
	Set up a \emph{comb} (over A) of size $n \in \N$  is an $n$-tuple
	$c \eqdef \tup{s_1, \ldots, s_n}$ of sequences $s_i \in A^*$
	over~$A$ (n is the number of elements in A)
	Each sequence $s_i$ of the $n$-tuple is called a \emph{spike} 
	which contains all events that are in immediate conflict with $e_{i} \in A$. (Each event has a attribute to store all its immediately-conflicting events).
	If a spike is empty ($e_i$ has no conflicting event), there is no J.
	
	Given a comb $c$ of size~$n$, witout any empty spike.
	a \emph{combination} of $c$ is any $n$-tuple $\tup{a_1, \ldots, a_n} \in A^n$
	such that $a_i \in A$ is one of the elements of the sequence $s_i \in A^*$, for
	$i \in \set{1, \ldots, n}$.
\item
	If $\exists e_i$: $e_c \cup C$ is not a configuration (1), discard the combination
	If there exists any two events in $[e_i]$ in conflict, discard the combination
\item
	If $\tup{a_1, \ldots, a_n}$ is conflict free (there does not exist any pair of events which are in conflict)
	J will be the union of all their local configuration: $ J = \cup [e'_i]$ (2)

\end{itemize}
\subsubsection{Check conflict between two arbitrary events}

How to check if two events e and e' are in conflict.
\begin{itemize}
	\item e and e' are in the same process: $p(e) = p(e')$ , apply \cref{a:layer_tree} for tree of events in same process
	\item e and e' are in different processes: $p(e)\neq p(e')$
		\begin{itemize}
			\item touch the same variable: $v(e) = v(e')$ and $ type(e) = type(e') = WR$ , apply \cref{a:layer_tree} for 						tree of WR events 
			\item touch the same variable: $v(e) = v(e')$ and $ type(e) = type(e') = SYN$ , apply \cref{a:layer_tree} for 						tree of SYN
			\item touch the same variable: $v(e) = v(e')$ and $ type(e) = RD$ and $type(e') = WR$ or reverse
			or touch different variables: $v(e) \neq v(e')$, store more information:	
			\begin{itemize}
				\item For each event e, use a vector $v = (e_1, e_2...,e_n)$  (n is number of variables in the model)
				with $e_i$ is the maximal event (RD, SYN, WR) touching the $v_i$ variable in e's local configuration:
				
				$e_i \in  \left[ e \right]: v(e_i) = v_i$ 
				and $ !\exists e_i' \in \left[ e \right] : v(e_i') = v_i$ 
				and $e_i < e_i'$ .
				\item Apply \cref{a:layer_tree} to check conflict for all pairs of events $(e_i, e_i')$ with $e_i \in v, e_i'\in v'$
			\end{itemize}
				
			
		\end{itemize}
\end{itemize}
\noindent
\textbf{Data structure:}
Using template struct \verb!Node:!
\begin{itemize}
	\item \textit{depth}: the distance from the root
	\item \textit{*pre}: according to the type of tree, it points to a predecessor in the same process or touching the same 					  variable.
	\item \textit{interparents}: list of its parents in different internal trees
\end{itemize}

\noindent
Each \verb!MultiNode! has the following attributes:
\begin{itemize}
	\item list of two \verb!Node! (first one for process, second one for variable)
	\item a template function $pred()$ to locate the predecessor corresponding to type of \verb!Node!
\end{itemize}

\begin{algorithm}
\noindent
 Assume e.depth > e'.depth, d = e.depth - e'.depth, do as the following:
\begin{enumerate}
\item
	If d < k then from $e$, repeat going back d times by the 			pointer $pre$ to find $e": e".depth = e'.depth$ and $ e" < e' $
\item 
	If d > k, $m = log_k(e.depth)$
 	\begin{itemize}
 	\item
 		 If  $m \in N$, repeate $e" := e.InterParent[m-1]					$ until $e".depth = e'.depth$
	\item 
		If $m \notin N$, repeate $e":= e \rightarrow pre$ until 		$log_k(e".depth) \in N$. Apply the same algorithm as $m 		\in N$ to e" until $e".depth = e'.depth$
 	\end{itemize} 
\item 
	If $e" = e'$ then $e'< e$ else $e'\neq e$	 
\end{enumerate}
\caption{Decide the conflict between e and e' in the same tree}
\label{a:layer_tree}	
\end{algorithm}

\begin{figure}
\subfloat[original tree]{
\includegraphics[scale=0.2]{tree.png}
}
\subfloat[$k^{1}$ tree]{
\includegraphics[scale=0.3]{tree1.png}
}
\subfloat[$k^{2}$ tree]{
\includegraphics[scale=0.3]{tree2.png}
}
\label{fig:trees}
\caption{Trees with k=2}
\end{figure}

\subsubsection{Layered tree:}
A tree of events in the same process or touching the same variable where events at the same depth have the same transition. That means they are in conflict.

Using the idea of skip list to go fast from the current node to target (see \ref{fig:trees}. In Node, a list of its parents in internal trees $ InterParents = (i_1, i_2,..,i_m)$ stored, while $i_j$ $(j=1..m)$ is the node's parent in $k^{j}$ tree, k (k > 1) is a constant choosen to skip nodes in trees, and a $k^{j}$ tree is a tree where a unit of depth is $k^{j}$

\verb!Store vector interparents!:
e is an event about to add to unfolding.
\begin{itemize}
\item 
	If $log_k(e.depth) \notin N$, $e.InterParents$ is 				empty.
\item 
	If $m = log_k(e.depth) \in N$, repeate $e' = e					\rightarrow pre$ k times.
	Assign $e.InterParents[0] = e'$
\end{itemize}

\begin{algorithm}
\noindent
For each event $e_i \in D$ repeat the following:
\begin{enumerate}
\item
	Let $c \eqdef \tup{s_1, \ldots, s_n}$ be the comb 				associated to A . 
	c is computed by adding all events in $e_i->dicfl$ to its 		corresponding spike.
\item
	Enumerate all combinations $\tup{e_1, \ldots, e_n}$ of $c$.
\item
	For any of them, do:
	\begin{enumerate}
\item 
    	If $\tup{e_1, \ldots, e_n}$ is conflict-free, get J from 				union of their all local configurations.
	    If there is one couple in conflict, then discard and take next combination
	\end{enumerate}
\item End.
\end{enumerate}
\caption{Computing all alternatives J for D after C}
\label{a:alter}
\end{algorithm}


\section{LLVM Frontend}

\subsection*{Pass 1: Sanity Checks}

Conditions to accept the input LLVM program:

\begin{itemize}
\item
  \verb!pthread_create! must be called directly from the main function and not
  in a loop or within a conditional.
\item
  \verb!printf!,
  \verb!pthread_{create,join,mutex_lock,mutex_unlock}! are the only function calls
  allowed (\verb!create! only in main).
\item
  All \verb!alloca! must be found in the first \verb!BasicBlock! of the
  function, and no block can jump into that block (not in a loop).
\item
  All variables in the C program are integers or arrays integers.
\end{itemize}

\subsection*{Pass 2: Construction of 3-address IR}

\subsection*{Pass 2.1: Identification of Threads}

\begin{itemize}
\item Number of threads given on command line
\item Finding out the C function executed by each thread
\end{itemize}

\subsection*{Pass 2.3: Allocation of memory}

\begin{itemize}
\item
  For each global symbol (\verb!@sym!), allocated memory space (\verb!alloca!
  instruction), and local register (\verb!%sym!) we allocate space in the
  memory of our virtual machine
\item
  We generate a symbol table mapping each address to a textual name.
\end{itemize}

\subsection*{Pass 2.4: Translation to 3-address IR}

Textual format and translation of LLVM opcodes in
\verb!doc/internals/3addr-ir.rst!.

\subsection*{Pass 2.5: Reduction of target variables based on live variable
analysis}

Only if we have time, although this could be done based on LLVM information and
directly during the translation of LLVM instructions to ou 3-address code.

\url{https://en.wikipedia.org/wiki/Live_variable_analysis}

\subsection*{Pass 3: Construction of Large-Block Encoding}

\subsection*{Pass 3.1: Identification of local and global variables}
\begin{itemize}
\item
  For us a variable is a 4 bytes block or an 8 bytes block, starting at an
  address multiple of, respectively, 4 or 8 bytes. Any memory access should
  regard exactly the 4 or 8 bytes inside a variable or any byte or 2 bytes inside a
  variable, but should never involve bytes belonging to two variables.
  Make a pass that ensures this for directy memory access instructions, for
  indirect accesses we will pray (think of this in the future).
\item
  A symbol (pair address-size $\tup{a,s} \in \N \times \N$) is \emph{local} to a
  thread if that thread is the only one that can modify the addresses
  $a, a+1, a+2, \ldots, a+s-1$.
  It is \emph{global} if it is not local.
  Make a pass to detect the variables local to each thread and the global ones.
\item
  We assume that one thread will never pass a pointer to some of its local
  variables or arrays to the other thread. On a later stage we will implement a
  points-to static analysis to detect this.
  So for now we ingore the \verb!movid! and \verb!movis! instructions.
\end{itemize}

\subsection*{Pass 3.2: Instruction splitting: 0 or 1 global access per instruction}

Rewrite instructions that make use of 2 or 3 global addresses to make use of at
most 1 global variable.
Use auxiliary local variables to store intermediate values. Easy.

For \verb!movis!, \verb!movid!, \verb!brz!, and \verb!brnz! instructions,
rewrite them so they use 0 global addresses.

\subsection*{Pass 3.3: Construction of large blocks}

An indirect instruction is either \verb!movid! or \verb!movis!.
A local instruction is one that only refers to local addresses and is not
indirect.
A branch instruction is either
\verb!brz! or \verb!brnz! (by assumption branch instructions are local).
A global instruction is one that is not local or indirect.

The first block of a thread is composed of all instructions of the first basic
block that are local and not branch.

All remaining blocks start at a
\begin{itemize}
\item branch instructions,
\item indirect instruction, or
\item global instruction.
\end{itemize}

\section{FIXMEs}

- do we need \verb!post_*! in any event?

- do we need \verb!pre_mem! in \verb!WR! events?


\bibliographystyle{splncs}
\bibliography{refs}

\end{document}

