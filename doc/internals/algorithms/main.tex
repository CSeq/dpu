\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[noadjust,nosort]{cite}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{MnSymbol}
%\usepackage{thmtools}
%\usepackage{thm-restate}
\usepackage{booktabs}
\usepackage{figlatex}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{xspace}
\usepackage[super]{nth}
\usepackage{multicol}
\usepackage{microtype}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage[center,width=152mm,height=235mm]{crop}
%\usepackage[pagewise,switch]{lineno} % switch, modulo, pagewise
\usepackage{hyperref}
%\usepackage[linesnumbered,lined,noend,ruled]{algorithm2e}
\usepackage[lined,noend,ruled]{algorithm2e}
\usepackage[capitalise,english,nameinlink]{cleveref} % load after algorithm2e and hyperref

\hypersetup{
  bookmarksdepth=2,
  bookmarksnumbered=true,
  bookmarksopen=true,
  bookmarksopenlevel=2,
  colorlinks=true,
  linktocpage=true,
  breaklinks=true,
  pageanchor=true,
  allcolors=[rgb]{0.6,0.0,0.0},
  pdftitle={DPU's data structures and algorithms},
  pdfauthor={Huyen N.T.T, César Rodríguez}
}

\input{defs}

\title{DPU's Data Structures and Algorithms}
%\author{Huyen Nguyen \and C\'esar Rodr\'{\i}guez}
\author{TBD}
\institute{Université Paris 13, Sorbonne Paris Cité, LIPN, CNRS, France}

\begin{document}

\maketitle

\begin{abstract}
TBD
\end{abstract}

\section{Execution Model}
\label{s:model}

Relevant classes:
\verb!Machine!,
\verb!Process!,
\verb!Trans!,
\verb!State!

Transition types :
\begin{itemize}
\item
  \verb!RD! Represents a transition that performs a certain amount of
  local (independent) work plus a single read operation on some global variable.
\item
  \verb!WR! Represents a transition that performs a certain amount of
  local (independent) work plus a single write operation on some global variable.
\item
  \verb!LOC! Represents a transition that only performs local (independent)
  operations.
\item
  \verb!SYN! Represents a synchronization operation, intended to model a
  lock or unlock operation on a mutex.
\end{itemize}

\subsection{Data Structure}

FIXME

\section{Unfolding}

Relevant classes:
\verb!Unfolding!.

\subsection{Data Structure}

A vector of \verb!Event!s, a pointer to the bottom event, and a reference
to the \verb!Machine!.

\section{Event}
Relevant classes:
\verb!Event!.

Events represent the occurrence of transitions.
They store pointers to all their immediate causal predecessors (ICPs), and some of
the immediate causal successors (ICSs).
The number of ICPs is determined by the type of the transition they
represent:

\begin{itemize}
\item \verb!LOC! events: 1 predecessor (process)
\item \verb!SYN! events: 2 predecessors (process, last \verb!SYN! on same variable)
\item \verb!RD!  events: 2 predecessor (process + last \verb!RD! or
	\verb!WR! operation on the same variable)
\item \verb!WR!  events: 1 predecessor (process) + one predecessor per
	process (last \verb!RD! or \verb!WR! operation on that process)
\end{itemize}

The immediate causal successors of one event are determined by those events
for which the event is an immediate causal predecessor. Some of the causal
successors are stored in the \verb!Event! class, but not all.

FIXME -- some of these events are only causal predecessors or successors,
not necessarily immediate predecessors or successors.

\subsection{Data Structure}

The members of the class \verb!Event! that are relevant on each instance of
the class depend on the type of the transition represented by the event.

All kinds of events store:
\begin{itemize}
\item
  \verb!trans!: a pointer to the transition it represents.
\item
  \verb!localvars!: vector (\verb!std::vector!) of \verb!uint32_t! values
  containing the value of the variables whose addresses are strored in
  \verb!this->trans->localvars!.
\item
  \verb!pre_proc!: (ICP) a pointer to the last event in the same thread.
\item
  \verb!post_proc!: (ICSs) a vector (\verb!std::vector!) of pointers to
  the next events in the same thread.
\end{itemize}
%
For \verb!SYN! events :
\begin{itemize}
\item
  \verb!pre_mem!: (ICP) pointer to the last \verb!SYN! event on the same
  variable, possibly performed by the same thread or another thread.
  Recall that \verb!SYN! operations on the same variable induce a tree when
  regarded unfolding-wise, and a total order (a branch of that tree) when
  the attention is reduced to an arbitrary configuration.
  In this regard, \verb!pre_mem! is a pointer to the node's parent in that
  tree.
\item
  \verb!post_mem!: (ICSs) vector (\verb!std::vector!) of pointers to
  the immediate next \verb!SYN! operations on the same variable, in this or
  another thread. These are the children of the aforementionned
  unfolding-wise tree.
\item
  \verb!val!: the value written by this event to the variable \verb!trans->var!
\end{itemize}
%
For \verb!RD! events :
\begin{itemize}
\item
  \verb!pre_mem!: (ICP) pointer to the last \verb!RD! or \verb!WR! event of
  the same thread. Observe that we do not store anything in the
  \verb!post_mem! vector.
\end{itemize}
%
Finally, for \verb!WR! events :
\begin{itemize}
\item
  \verb!pre_mem!: (causal predecessor) pointer to the last event
  representing a \verb!WR! operation performed on the same variable.
  Recall that \verb!WR! operations on the same variable induce a tree when
  regarded unfolding-wise, and a total order (a branch of that tree) when
  the attention is reduced to an arbitrary configuration.
  In this regard, \verb!pre_mem! is a pointer to the node's parent in that
  tree.
\item
  \verb!post_mem!: (causal successsor) vector (\verb!std::vector!) of
  pointers to the next \verb!WR! operations on the same variable, in this
  or another thread. These are the children of the aforementionned
  unfolding-wise tree.
\item
  \verb!pre_readers!: (immediate and not immediate causal predecessors)
  vector (\verb!std::vector!) of pointers to events (one per thread).
  The event pointed is the last \verb!RD! or \verb!WR! operation on the
  same variable performed in that thread.
\end{itemize}

FIXME - incomplete; look at my notes and fix


\subsection{Events in Conflict with an Event}

TBD.

\section{Configuration}
Relevant classes:
\verb!Config!.

\subsection{Data Structure}

\begin{itemize}
\item
  \verb!state!: the state reached by the configuration (type \verb!ir::State!).
\item
  \verb!latest_proc!:
  a vector of pointers to events. The size of the vector is the number of
  processes. Conceptually this represents a function from the set of processes
  to the set of events, which gives, for every process, the (unique) causally
  maximal event of that process in the configuration.

\item
  \verb!latest_wr!
  a vector of pointers to events. Size: the number of variables of the system.
  Conceptually this represents a function from the set of variables
  to the set of events, which gives, for every variable, latest (causally
  maximal) event that wrote to the variable (that event must correspond to a
  \verb!SYN! or \verb!WR! transition).

\item
  \verb!latest_op!
  a vector of pointers to events. Size: the number of variables times number of
  processes.
  Conceptually this represents a function $f \colon P \times V \to C$,
  where $P$ is the set of processes, $V$ is the set of variables, and $C$ the
  set of events in the configuration.
  The event $f (p,v)$ is the latest (causally maximal) operation that process
  $p$ performed on variable $v$ (it will correspond to a \verb!SYN!, \verb!WR!,
  or \verb!RD! transition).
\end{itemize}

\subsection{Enabled Events}

\begin{itemize}
\item
  Enumerate all transitions enabled at the \verb!state!
\item
  Using the members variables it is easy to construct new events.
\end{itemize}

\subsection{Conflicting Extensions}


Let $M$ be the input program model.
Let $\unf M \eqdef \tup{E,<,\cfl,h}$ be the unfolding of $M$.
Let $t$ be a transition of $M$ and $C \subseteq E$ a configuration of $\unf M$.
See \cite{RSSK15long} for a formal definition.

In the sequel we give an algorithm to compute the \emph{conflicting extensions}
of~$C$, defined as
$
\cex C \eqdef
\set{e \in \ex C \colon \exists e' \in C,\, e \icfl{} e'},
$
where the \emph{extensions} of~$C$, written $\ex C$,
are all those events outside~$C$ whose causes are included in~$C$.
Formally,
$
\ex C \eqdef
\set{e \in E \colon e \notin C \land \causes e \subseteq C}
$, where
$\causes e \eqdef \set{e' \in E \colon e' < e}$.
Again, see \cite{RSSK15long} to gain intuition about the necessity and motivation
behind these definitions.

Assume we are given a configuration $C$.
We want to compute all events in $\cex C$.
Let \verb!t! be a transition of $M$.
For each type of transition we give a different algorithm that computes all
events $e \in E$ such that $h(e) = t$:
\begin{itemize}
\item Apply \cref{a:cex_rd} if $t$ is \verb!RD! transition.
\item Apply \cref{a:cex_syn} if $t$ is \verb!SYN! transition.
\item Apply \cref{a:cex_wr} if $t$ is \verb!WR! transition.
\item If $t$ is a \verb!LOC! transition, then there is no conflicting extension
$e \in \cex C$ such that $h(e) = t$.
\end{itemize}

\begin{theorem}[Conflicting extensions]
Let $M$ be the model of a program as described in \cref{s:model}.
Let $C$ be an arbitrary configuration of $\unf M$.
Then the algorithm above computes exactly the set of events $\cex C$.
\end{theorem}
\begin{proof}
TBD
\end{proof}

\Cref{a:cex_wr} is slightly more complex than the algorithms for read and
synchronization transitions, and requires the following additional definitions.

Let $A$ be a set.
A \emph{comb} over~$A$ of size $n \in \N$ is an $n$-tuple
$c \eqdef \tup{s_1, \ldots, s_n}$ of sequences $s_i \in A^*$
over~$A$.
Each sequence $s_i$ of the $n$-tuple is called a \emph{spike}.
Given a comb $c$ of size~$n$,
a \emph{combination} of $c$ is any $n$-tuple $\tup{a_1, \ldots, a_n} \in A^n$
such that $a_i \in A$ is one of the elements of the sequence $s_i \in A^*$, for
$i \in \set{1, \ldots, n}$.

Let $e \in E$ be a \verb!WR! event in $\unf M$.
Let $\set{e_1, \ldots, e_n}$ be the set of \verb!pre_readers! of~$e$.
We define the \emph{comb associated to $e$} as the only comb
$\tup{s_1, \ldots s_n}$ of size~$n$ over~$E$ defined as follows:
\begin{itemize}
\item
  Sequence $s_i \in E^*$ is formed by all \verb!RD! events and the only
  \verb!WR! event that can be found by recursively exploring the pointer
  \verb!pre_mem! starting from event~$e_i$. The last event to include in the
  sequence is the first event of type \verb!WR! found during the exploration of
  the list.
\end{itemize}


\begin{algorithm}
\noindent
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!em = e->pre_mem!
\item If $\verb!em! < \verb!ep!$, then goto End.
\item If \verb!em! is \verb!RD! then set \verb!em = em->pre_mem!
\item If not it must necessarily be \verb!WR!; then set \verb!em = em->pre_readers[t->proc]!
\item (Warning: check for the bottom event in previous calculation)
\item
  Create (or retrieve) an event \verb!ex! such that
  \begin{itemize}
  \item \verb!ex->trans = t!,
  \item \verb!ex->pre_proc = ep!,
  \item \verb!ex->pre_mem = em!,
  \end{itemize}
\item Event \verb!ex! is in $\cex C$
\item Goto 4.
\item End.
\end{enumerate}
\caption{Conflicting extesions associated to \texttt{RD} transitions.}
\label{a:cex_rd}
\end{algorithm}

\begin{algorithm}
\noindent
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!em = e->pre_mem!
\item If $\verb!em! < \verb!ep!$, then goto End.
\item Set \verb!em = em->pre_mem!
\item (Warning: check for the bottom event in previous calculation)
\item
  Create (or retrieve) an event \verb!ex! such that
  \begin{itemize}
  \item \verb!ex->trans = t!,
  \item \verb!ex->pre_proc = ep!,
  \item \verb!ex->pre_mem = em!,
  \end{itemize}
\item Event \verb!ex! is in $\cex C$
\item Goto 3.
\item End.
\end{enumerate}

\caption{Conflicting extesions associated to \texttt{SYN} transitions.}
\label{a:cex_syn}
\end{algorithm}

\begin{algorithm}
\noindent
For each event $e \in C$ such that \verb!e->trans == t!, repeat the following:
\begin{enumerate}
\item Set \verb!ep = e->pre_proc!
\item Set \verb!ew = e!
\item
  Let $M$ be the set of maximal events in $[e_p]$ that read or write variable
  \verb!t->var! ($M$ will either be a singleton with only \verb!WR! event or
  will contain exactly one \verb!RD! or \verb!WR! event per process)
\item If $\verb!ew! < \verb!ep!$, then goto End.
\item Let $c \eqdef \tup{s_1, \ldots, s_n}$ be the comb associated to \verb!ew!
\item
  Enumerate all combinations $\tup{e_1, \ldots, e_n}$ of $c$.
  For any of them, do:
  \begin{enumerate}
  \item
    If $\tup{e_1, \ldots, e_n} = \verb!e->pre_readers!$, then discard and take
    next one.
  \item
    If any event in $\set{e_1, \ldots, e_n}$ a causal predecessor of some event in
    $M$, then discard and take the next combination.
  \item
    Create (or retrieve) an event \verb!ex! such that
    \begin{itemize}
    \item \verb!ex->trans = t!,
    \item \verb!ex->pre_proc = ep!,
    \item \verb!ex->pre_readers = {e_1, ..., e_n}!,
    \end{itemize}
  \item
    Set \verb!ew! to the last element (\verb!WR! event) of $s_1$
    (or $s_2$, or $s_3$, or \ldots)
  \end{enumerate}
\item Goto 3.
\item End.
\end{enumerate}
\caption{Conflicting extesions associated to \texttt{WR} transitions.}
\label{a:cex_wr}
\end{algorithm}

\subsection{Alternatives}
\begin{definition}
Given a configuration $C \subseteq U$ and a set of events $D \subset U$, an alternative to D after C is an configuration $J \subset U $ such that:
\begin{itemize}
\item 
	$C \cup J$ is a configuration
\item
	for all event $e \in D$ , there is some $e'\in C \cup J$ such that $e' \in  \icfl{e}$
\end{itemize}
\end{definition}


\noindent
We have $\forall e \in D: $ $e \in cex(C)$ or $e \in en(C)$.
\begin{enumerate}
\item
	If  $e \in cex(C)$, there exists an event $e' \in C: e' \icfl e$. So, it shouldn't be taken into account.
\item
	If $e \in en(C)$, do the followings to find out all possible J:
\end{enumerate}

\begin{itemize}
\item 
	$A = \{e_i \in D: e_i \in en(C)\}$. 
	Set up a \emph{comb} (over A), an $n$-tuple
	$c \eqdef \tup{s_1, \ldots, s_n}$ of sequences $s_i \in A^*$
	(n is the number of elements in A).
	\begin{itemize}
	\item
		Each sequence $s_i$ of the $n$-tuple is called a \emph{spike} which contains all events that are in immediate conflict with $e_{i} \in A$. (Each event has a attribute to store all its immediately-conflicting events).
	\item
		If a spike is empty ($e_i$ has no conflicting event), there is no J.
	\end{itemize}
	
\item
	Given a comb $c$ witout any empty spike, a \emph{combination} of $c$ is any $n$-tuple $\tup{a_1, \ldots, a_n} \in A^n$ such that $a_i \in A$ is one of the elements of the sequence $s_i \in A^*$, for
	$i \in \set{1, \ldots, n}$.
\item
	\begin{itemize}
	\item
		If $\exists e_i$: $e_c \cup C$ is not a configuration, condition (1) is not satisfied, then discard the combination
	\item
		If there exists any two events in $[e_i]$ in conflict, discard the combination.
	\item
		If $\tup{a_1, \ldots, a_n}$ is conflict free (there does not exist any pair of events which are in conflict) J will be the union of all their local configuration: $ J = \cup [e'_i]$. Condition (2) is satisfied.
	\end{itemize}
\end{itemize}

\begin{algorithm}
\noindent
For each event $e_i \in D$ repeat the following:
\begin{enumerate}
\item
	Let $c \eqdef \tup{s_1, \ldots, s_n}$ be the comb associated to A . 
	c is computed by adding all events in $e_i->dicfl$ to its corresponding spike.

\item
	Enumerate all combinations $\tup{e_1, \ldots, e_n}$ of $c$.
\item
	For any of them, do:
	\begin{enumerate}
\item 
    	If $\tup{e_1, \ldots, e_n}$ is conflict-free, get J from union of their all local configurations.
	    If there is one couple in conflict, then discard and take next combination
	\end{enumerate}
\item End.
\end{enumerate}
\caption{Computing all alternatives J for D after C}
\label{a:alter}
\end{algorithm}

\subsubsection{Checking conflict between two arbitrary events:}
Given two arbitrary events $e$ and $e'$ in the unfolding, decide if they are in conflict or not.
\begin{enumerate}
	\item e and e' are in the same process: $p(e) = p(e')$ , apply \cref{a:layer_tree} for tree of events in same process
	\item e and e' are in different processes: $p(e)\neq p(e')$
		\begin{itemize}
			\item touch the same variable: $v(e) = v(e')$ and $ type(e) = type(e') = WR$ , apply \cref{a:layer_tree} for 						tree of WR events 
			\item touch the same variable: $v(e) = v(e')$ and $ type(e) = type(e') = SYN$ , apply \cref{a:layer_tree} for 						tree of SYN
			\item Other cases (touch the same variable: $v(e) = v(e')$ and (RD,WR) (WR,RD) (RD, RD) or two events touching different variables: $v(e) \neq v(e')$), store more information:	
			\begin{itemize}
				\item For each event e, use a vector $maxevt = (e_1, e_2...,e_n)$  (n is number of variables in the model)
				with $e_i$ is the maximal event (RD, SYN, WR) in e's local configuration which touches $v_i$ variable :
				
				$e_i \in  \left[ e \right]: v(e_i) = v_i$ 
				and $ \nexists e_i' \in \left[ e \right] : v(e_i') = v_i$ 
				and $e_i < e_i'$ .
				\item Apply \cref{a:layer_tree} to check conflict for all pairs of events $(e_i, e_i')$ with $e_i \in v, e_i'\in v'$
			\end{itemize}	
		\end{itemize}
\end{enumerate}

\noindent
\textbf{Data Structure}

In Event class, there is a vector \verb!maxevt! $maxevt = (e_1, e_2...,e_n)$ (n is the number of global variables) which stores pointers to maximal events for all global variables $v_i$.

\noindent
\textbf{Initialize the vector of maximal events:}
For an event e:
\begin{itemize}
\item
	If e is a LOC: \verb!e.maxevt = e.pre_proc.maxevt!
\item
	If e is a RD or SYN touching $x$ variable: 
	\begin{itemize}
	\item
		\verb!e.maxevt(x) = e!
	\item	
		$\forall y \neq x$: 
		
		$e.maxevt(y) = max(e.pre\_proc.maxevt(y), e.pre\_mem.maxevt(y) )$
	\end{itemize}
\item
	If e is a WR: 
	\begin{itemize}
	\item
		\verb!e.maxevt(x) = e!
	\item	
		$\forall y \neq x$:
		
		$e.maxevt(y) = max(e.pre\_proc.maxevt(y), max(e.pre\_readers[i])(y))$
		
		while $pre\_readers[i]$ is the previous reader corresponding to process i 
		
	\end{itemize}
\end{itemize}



\subsubsection{Checking conflict between two events in the same tree}
Tree are divided into layers whose events have the same depth and are in immediate conflict.
e and e' are two events in that tree at depths $e.depth$ and $e'.depth$ respectively.
\begin{itemize}
\item
	If $e.depth = e'.depth$, then $e \icfl e'$
\item
	If $e.depth \neq e'.depth$, without loss of any generality, assume $ depth(e) > depth(e')$ . Find an event $e": e" < e$ and $e".depth = e'.depth$ . If $e" \equiv e'$, then $e'$ and $e$ are in causality, else they are in conflict.
\end{itemize}

	
To quickly find $e"$ through the tree, we use the idea of skip list (see \ref{fig:example}. Accordingly, in each node, a list of skip predecessors $ skip\_preds = (i_1, i_2,..,i_m)$ are stored, where $i_j$ $(j \in [1,m] )$ is the node's predecessor in $k^{j}$ distance of depth, k (k > 1) is a constant distance in depth choosen to skip.

\begin{figure}
\subfloat[original tree]{
\includegraphics[scale=0.2]{tree.png}
}
\subfloat[$k^{1}$ tree]{
\includegraphics[scale=0.3]{tree1.png}
}
\subfloat[$k^{2}$ tree]{
\includegraphics[scale=0.3]{tree2.png}
}
\label{fig:example}
\caption{Trees with k=2}
\end{figure}

\noindent
\textbf{Data structure:}
Using template struct \verb!Node<T>:!
\begin{itemize}
	\item \textit{depth}: the distance from the root
%	\item \textit{*pre}: according to the type of tree, it points to node of T which is immediate predecessor
	\item \textit{skip\_preds}: list of pointers to its k-skip predecessors of type T.	
(T can be an event in the same process or touching the same variable)
\end{itemize}

To apply the algorithm of skip list to layered trees, we use a template class \verb!MultiNode<T>! (T is Event) which has the following attributes:
\begin{itemize}
	\item list of two \verb!Node! (first one for process, second one for variable)
	\item a template function $pred()$ to locate the predecessor corresponding to type of \verb!Node!
\end{itemize}
 
 Class Event inherits \verb!MultiNode<T>! and has two template function indicating which type of Node to take into account.
\begin{itemize}
\item	
	\verb!Node<Event> &proc!: return node in equivalant \textit{process} tree
\item	
	\verb!Node<Event> &var!: return node in equivalant \textit{variable} tree 	
\end{itemize}

\noindent
\textbf{Initialize a list of skip predecessors} \verb!skip_preds:!
Firstly, we need to define the size $s$ of vector \verb!skip_preds! of a node
\begin{itemize}
\item 
	If $e.depth \mod k \neq 0$,  then $s = 1$.
\item 
	If $e.depth \mod k = 0 $, compute $m = \left \lfloor log_k(e.depth) \right\rfloor$, size of the list is $s = max(i): i \in [1,m]: e.depth \mod k^{i} = 0 $ 
\end{itemize}
Next, compute the entire list of skip predecessors for e. For every node, $e.skip\_preds[i]$ is a predecessor which is in a depth distance of $k^{i}$ with e, so that:
\begin{itemize}
\item
	The first element of the list \verb!skip_preds[0]! indicates the predecessor which is in a depth distance of $k^0 = 1$. It is actually \verb!pre_proc! or \verb!pre_mem! of corresponding event.
\item
	For $\forall i \in [1,s]: skip\_preds[i] = max(\{e": e" < e$ and $e".depth \mod k^i = 0\})$ which can be computed by going back k times with $skip\_preds[i-1]$: \\
	 \verb!e.skip_preds[i] = e.skip_preds[i-1]....skip_preds[i-1]! (k times) 
\end{itemize}


\begin{algorithm}
\noindent
Assume $e.depth > e'.depth$, and , to reach e', do as follows:
\begin{enumerate}
\item
	\verb!Set next = e!
\item
	\verb!while! $next.depth \neq e'.depth$ \verb!do!
	\begin{itemize}
	\item
		\verb!Set d  = next.depth - e'.depth!
	\item
		\verb!Set i  =! $ \left \lfloor log_k(d) \right \rfloor$
	\item
		\verb!while! ($ next.depth \mod k^{i} \neq 0$)   \space \verb!do!
		    $i = i - 1$
	\item
		\verb!Set! $next = next.skip\_preds[i]$ 
 	\end{itemize} 
\item 
	If $next \equiv e'$ then 
		$e'< e$ 
	
	else $e'\cfl e$	 
\end{enumerate}
\caption{Decide the conflict between e and e' in the same tree}
\label{a:layer_tree}	
\end{algorithm}


\section{LLVM Frontend}

\subsection*{Pass 1: Sanity Checks}

Conditions to accept the input LLVM program:

\begin{itemize}
\item
  \verb!pthread_create! must be called directly from the main function and not
  in a loop or within a conditional.
\item
  \verb!printf!,
  \verb!pthread_{create,join,mutex_lock,mutex_unlock}! are the only function calls
  allowed (\verb!create! only in main).
\item
  All \verb!alloca! must be found in the first \verb!BasicBlock! of the
  function, and no block can jump into that block (not in a loop).
\item
  All variables in the C program are integers or arrays integers.
\end{itemize}

\subsection*{Pass 2: Construction of 3-address IR}

\subsection*{Pass 2.1: Identification of Threads}

\begin{itemize}
\item Number of threads given on command line
\item Finding out the C function executed by each thread
\end{itemize}

\subsection*{Pass 2.3: Allocation of memory}

\begin{itemize}
\item
  For each global symbol (\verb!@sym!), allocated memory space (\verb!alloca!
  instruction), and local register (\verb!%sym!) we allocate space in the
  memory of our virtual machine
\item
  We generate a symbol table mapping each address to a textual name.
\end{itemize}

\subsection*{Pass 2.4: Translation to 3-address IR}

Textual format and translation of LLVM opcodes in
\verb!doc/internals/3addr-ir.rst!.

\subsection*{Pass 2.5: Reduction of target variables based on live variable
analysis}

Only if we have time, although this could be done based on LLVM information and
directly during the translation of LLVM instructions to ou 3-address code.

\url{https://en.wikipedia.org/wiki/Live_variable_analysis}

\subsection*{Pass 3: Construction of Large-Block Encoding}

\subsection*{Pass 3.1: Identification of local and global variables}
\begin{itemize}
\item
  For us a variable is a 4 bytes block or an 8 bytes block, starting at an
  address multiple of, respectively, 4 or 8 bytes. Any memory access should
  regard exactly the 4 or 8 bytes inside a variable or any byte or 2 bytes inside a
  variable, but should never involve bytes belonging to two variables.
  Make a pass that ensures this for directy memory access instructions, for
  indirect accesses we will pray (think of this in the future).
\item
  A symbol (pair address-size $\tup{a,s} \in \N \times \N$) is \emph{local} to a
  thread if that thread is the only one that can modify the addresses
  $a, a+1, a+2, \ldots, a+s-1$.
  It is \emph{global} if it is not local.
  Make a pass to detect the variables local to each thread and the global ones.
\item
  We assume that one thread will never pass a pointer to some of its local
  variables or arrays to the other thread. On a later stage we will implement a
  points-to static analysis to detect this.
  So for now we ingore the \verb!movid! and \verb!movis! instructions.
\end{itemize}

\subsection*{Pass 3.2: Instruction splitting: 0 or 1 global access per instruction}

Rewrite instructions that make use of 2 or 3 global addresses to make use of at
most 1 global variable.
Use auxiliary local variables to store intermediate values. Easy.

For \verb!movis!, \verb!movid!, \verb!brz!, and \verb!brnz! instructions,
rewrite them so they use 0 global addresses.

\subsection*{Pass 3.3: Construction of large blocks}

An indirect instruction is either \verb!movid! or \verb!movis!.
A local instruction is one that only refers to local addresses and is not
indirect.
A branch instruction is either
\verb!brz! or \verb!brnz! (by assumption branch instructions are local).
A global instruction is one that is not local or indirect.

The first block of a thread is composed of all instructions of the first basic
block that are local and not branch.

All remaining blocks start at a
\begin{itemize}
\item branch instructions,
\item indirect instruction, or
\item global instruction.
\end{itemize}

\section{FIXMEs}

- do we need \verb!post_*! in any event?

- do we need \verb!pre_mem! in \verb!WR! events?


\bibliographystyle{splncs}
\bibliography{refs}

\end{document}

